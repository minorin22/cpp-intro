<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ポインターの内部実装 | 江添亮のC++入門</title>
    <meta name="description" content="">
    <link rel="icon" href="64.png">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="152.png">
  <meta name="msapplication-TileImage" content="/144.png">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="assets/css/0.styles.17f32d1e.css" as="style"><link rel="preload" href="assets/js/app.8620998f.js" as="script"><link rel="preload" href="assets/js/2.7009e9ba.js" as="script"><link rel="preload" href="assets/js/35.2cf21250.js" as="script"><link rel="prefetch" href="assets/js/10.0bc4fb9f.js"><link rel="prefetch" href="assets/js/11.c5d46ffe.js"><link rel="prefetch" href="assets/js/12.cec763ba.js"><link rel="prefetch" href="assets/js/13.85764695.js"><link rel="prefetch" href="assets/js/14.56c0c5a1.js"><link rel="prefetch" href="assets/js/15.ba58285d.js"><link rel="prefetch" href="assets/js/16.663fe3ce.js"><link rel="prefetch" href="assets/js/17.b9e53cc4.js"><link rel="prefetch" href="assets/js/18.468131c1.js"><link rel="prefetch" href="assets/js/19.966431ea.js"><link rel="prefetch" href="assets/js/20.39088cad.js"><link rel="prefetch" href="assets/js/21.f1d2fbe4.js"><link rel="prefetch" href="assets/js/22.53af9436.js"><link rel="prefetch" href="assets/js/23.45c08f75.js"><link rel="prefetch" href="assets/js/24.fec53f63.js"><link rel="prefetch" href="assets/js/25.1c55ab94.js"><link rel="prefetch" href="assets/js/26.97221aa1.js"><link rel="prefetch" href="assets/js/27.ad617385.js"><link rel="prefetch" href="assets/js/28.1d1956f2.js"><link rel="prefetch" href="assets/js/29.bb17ac3f.js"><link rel="prefetch" href="assets/js/3.a3b2b660.js"><link rel="prefetch" href="assets/js/30.3861fe0d.js"><link rel="prefetch" href="assets/js/31.93e5e7a5.js"><link rel="prefetch" href="assets/js/32.7f1f5a03.js"><link rel="prefetch" href="assets/js/33.ba1ef509.js"><link rel="prefetch" href="assets/js/34.63b70d43.js"><link rel="prefetch" href="assets/js/36.93604af5.js"><link rel="prefetch" href="assets/js/37.132be8e6.js"><link rel="prefetch" href="assets/js/38.32a3f051.js"><link rel="prefetch" href="assets/js/39.bab7cf23.js"><link rel="prefetch" href="assets/js/4.3ff2fe10.js"><link rel="prefetch" href="assets/js/40.2cd9628c.js"><link rel="prefetch" href="assets/js/41.24bfe547.js"><link rel="prefetch" href="assets/js/42.39ebe085.js"><link rel="prefetch" href="assets/js/43.4ff95f43.js"><link rel="prefetch" href="assets/js/44.f1a016d7.js"><link rel="prefetch" href="assets/js/45.590d3d64.js"><link rel="prefetch" href="assets/js/46.46b99b9b.js"><link rel="prefetch" href="assets/js/47.483b5213.js"><link rel="prefetch" href="assets/js/48.65facf6a.js"><link rel="prefetch" href="assets/js/49.2bda166c.js"><link rel="prefetch" href="assets/js/5.7f8f4812.js"><link rel="prefetch" href="assets/js/50.858dc861.js"><link rel="prefetch" href="assets/js/51.a40bec0a.js"><link rel="prefetch" href="assets/js/52.f5dc4f7e.js"><link rel="prefetch" href="assets/js/53.4cfac598.js"><link rel="prefetch" href="assets/js/54.9b6224cf.js"><link rel="prefetch" href="assets/js/55.4fb7a3ba.js"><link rel="prefetch" href="assets/js/56.8a7823a6.js"><link rel="prefetch" href="assets/js/6.af1283dd.js"><link rel="prefetch" href="assets/js/7.401cafeb.js"><link rel="prefetch" href="assets/js/8.44430c93.js"><link rel="prefetch" href="assets/js/9.39e986e2.js">
    <link rel="stylesheet" href="assets/css/0.styles.17f32d1e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="index.html" class="home-link router-link-active"><!----> <span class="site-name">江添亮のC++入門</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="000-preface.html" class="sidebar-link">序</a></li><li><a href="001-intro.html" class="sidebar-link">C++の概要</a></li><li><a href="002-build.html" class="sidebar-link">C++の実行</a></li><li><a href="003-guide-to-c++.html" class="sidebar-link">C++ヒッチハイクガイド</a></li><li><a href="004-debug-compile-error.html" class="sidebar-link">デバッグ：コンパイルエラーメッセージの読み方</a></li><li><a href="005-the-restaurant-at-the-end-of-the-branch.html" class="sidebar-link">条件分岐の果てのレストラン</a></li><li><a href="006-debug-compile-warning.html" class="sidebar-link">デバッグ: コンパイル警告メッセージ</a></li><li><a href="007-standard-input.html" class="sidebar-link">最近体重が気になるあなたのための標準入力</a></li><li><a href="008-loop.html" class="sidebar-link">ループ</a></li><li><a href="009-vector.html" class="sidebar-link">メモリーを無限に確保する</a></li><li><a href="010-debug-printf.html" class="sidebar-link">デバッグ：printfデバッグ</a></li><li><a href="011-integer.html" class="sidebar-link">整数</a></li><li><a href="012-floating-point.html" class="sidebar-link">浮動小数点数</a></li><li><a href="013-names.html" class="sidebar-link">名前</a></li><li><a href="014-iterator.html" class="sidebar-link">イテレーターの基礎</a></li><li><a href="015-reference.html" class="sidebar-link">lvalueリファレンスとconst</a></li><li><a href="016-algorithm.html" class="sidebar-link">アルゴリズム</a></li><li><a href="017-lambda.html" class="sidebar-link">ラムダ式</a></li><li><a href="018-class.html" class="sidebar-link">クラスの基本</a></li><li><a href="019-operator-overloading.html" class="sidebar-link">より自然に振る舞うクラス</a></li><li><a href="020-array.html" class="sidebar-link">std::array</a></li><li><a href="021-three-virtues-of-a-programmer.html" class="sidebar-link">プログラマーの三大美徳</a></li><li><a href="022-implement-array.html" class="sidebar-link">配列</a></li><li><a href="023-template.html" class="sidebar-link">テンプレート</a></li><li><a href="024-more-array.html" class="sidebar-link">arrayをさらに実装</a></li><li><a href="025-array-iterator.html" class="sidebar-link">arrayのイテレーター</a></li><li><a href="026-exception.html" class="sidebar-link">傲慢なエラー処理: 例外</a></li><li><a href="027-pointer.html" class="sidebar-link">ポインター</a></li><li><a href="028-pointer-semantics.html" class="sidebar-link">意味上のポインター</a></li><li><a href="029-pointer-syntax.html" class="sidebar-link">文法上のポインター</a></li><li><a href="030-pointer-details.html" class="active sidebar-link">ポインターの内部実装</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="030-pointer-details.html#ポインターの内部実装" class="sidebar-link">ポインターの内部実装</a></li></ul></li><li><a href="031-iterator-operations.html" class="sidebar-link">イテレーター詳細</a></li><li><a href="032-memory-allocation.html" class="sidebar-link">動的メモリー確保</a></li><li><a href="033-vector-implementation.html" class="sidebar-link">vectorの実装 : 基礎</a></li><li><a href="034-vector-memory-allocation.html" class="sidebar-link">vectorの実装 : メモリー確保</a></li><li><a href="035-copy.html" class="sidebar-link">コピー</a></li><li><a href="036-move.html" class="sidebar-link">ムーブ</a></li><li><a href="037-rvalue-reference.html" class="sidebar-link">rvalueリファレンス</a></li><li><a href="038-move-semantics.html" class="sidebar-link">ムーブの実装</a></li><li><a href="039-disable-copy.html" class="sidebar-link">コピーの禁止</a></li><li><a href="040-smart-pointer.html" class="sidebar-link">スマートポインター</a></li><li><a href="041-move-support.html" class="sidebar-link">自作の数値クラスで演算をムーブに対応する方法</a></li><li><a href="042-string-intro.html" class="sidebar-link">文字列</a></li><li><a href="043-random.html" class="sidebar-link">乱数</a></li><li><a href="044-random-part2.html" class="sidebar-link">ポアソン分布</a></li><li><a href="045-random-part3.html" class="sidebar-link">正規分布</a></li><li><a href="046-random-part4.html" class="sidebar-link">サンプリング分布(sampling distributions)</a></li><li><a href="200-cpp.html" class="sidebar-link">Cプリプロセッサー</a></li><li><a href="300-multiple-source-files.html" class="sidebar-link">分割コンパイル</a></li><li><a href="400-gdb.html" class="sidebar-link">デバッガー</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="ポインターの内部実装"><a href="030-pointer-details.html#ポインターの内部実装" class="header-anchor">#</a> ポインターの内部実装</h2> <p>ポインターの意味上と文法上の解説は終えた。ここからはポインターの内部実装についてだ。ポインターの値とは外でもない、メモリー上のアドレスのことだ。</p> <h3 id="キロバイトとキビバイト"><a href="030-pointer-details.html#キロバイトとキビバイト" class="header-anchor">#</a> キロバイトとキビバイト</h3> <p>メモリーとアドレスについて解説する前に、キロバイト(Kilo byte)とキビバイト(Kibi byte)の違いについて解説する。</p> <p>キロ(Kilo)というのはSI接頭語で、$1000^1$を意味する。1キロは1000だ。SI接頭語にはほかにもメガ(Mega, $1000^2$)、ギガ(Giga, $1000^3$)やテラ(Tera, $1000^4$)などの接頭語もある。</p> <p>長さ1キロメートルは1000メートルで、重さ1キログラムは1000グラムだ。</p> <p>いま「このCPUのクロック周波数は1GHzだ」と言ったとき、それは$1000^3$Hz = $1000000000$Hzのことだ。</p> <p>しかし、メモリー容量だけは慣習的に$1000^n$ではなく、$1024^n$を使う。</p> <p>一般人が「このメモリーは1KBだ」と言ったとき、それは1024バイトのことだ。1GBのメモリーは$1024^3 バイト = 1073741824 バイト$だ。筆者が本書を執筆するのに使ったラップトップコンピューターは32GBのメモリーを積んでいるがこれは34359738368バイトだ。</p> <p>メモリーの容量が10進数ではなく2進数で数えられているのは、メモリーは2進数で扱うのがハードウェア的に都合がいいからだ。そのため、慣習的にキロは$1000^1$ではなく$1024^1$を意味するようになってしまった。</p> <p>このため、IEEE 1541では10進SI接頭語と対になる2進接頭語を定義した。</p> <p>接頭語                          値</p> <hr> <p>キビ(kibi, Ki)                  $2^{10}$
メビ(mebi, Mi)                  $2^{20}$
ギビ(gibi, Gi)                  $2^{30}$
テビ(tebi, Ti)                  $2^{40}$
ペビ(pebi, Pi)                  $2^{50}$
エクスビ(exbi, Ei)              $2^{60}$</p> <p>本書では1KBは1000バイトで、1KiBが1024バイトを意味する。</p> <h3 id="メモリーとアドレス"><a href="030-pointer-details.html#メモリーとアドレス" class="header-anchor">#</a> メモリーとアドレス</h3> <p>コンピューターにはメモリーやストレージと呼ばれる記憶領域がある。情報の最小単位はすでに学んだようにビットだが、情報をビット単位で扱うのは不便なので、慣習的に複数の連続したビットを束ねたバイトという単位で扱っている。1バイトはほとんどのアーキテクチャで8ビットだ。メモリーは複数の連続したバイト列で成り立っている。</p> <p>この連続したバイト列の中の任意の1バイトを指し示すのがアドレスだ。メモリーのバイト列の最初の1バイトのアドレスを0とし、次の1バイトアドレスを1とし、以降、その次を前のアドレスに1加えた値にしてみよう。</p> <p>そのようなメモリーとアドレスのコンピューターでは、1バイトの符号なし整数で表現されたアドレスは、256バイトのメモリーの中の任意の1バイトをアドレスとして参照することができる。</p> <p>これはとても抽象化された計算機で、現実の計算機はもっと複雑な実装になっている。しかしC++の規格としては、メモリーとはフラットな連続したバイト列であって、その任意の各バイトをアドレスから参照可能だという想定になっている。</p> <p>アドレスが1バイトの符号なし整数で表現され、そのすべてのビットが使われる場合、256バイトの連続したメモリーをアドレス可能だ。</p> <p>アドレスが2バイトならば、64KiBのメモリーをアドレス可能だ。</p> <p>アドレスが4バイトならば、4GiBのメモリーをアドレス可能だ。</p> <p>アドレスが8バイトならば、16EiBのメモリーをアドレス可能だ。</p> <p>ポインターの値というのは、このアドレスの値のことだ。</p> <h3 id="ポインターのサイズ"><a href="030-pointer-details.html#ポインターのサイズ" class="header-anchor">#</a> ポインターのサイズ</h3> <p>ポインターの値というのはアドレスの値だ。ポインターの値を格納するのにもメモリーが必要だ。ではポインターのサイズは何バイトあるのだろう。</p> <p>型<code>T</code>のサイズを調べるには<code>sizeof(T)</code>を使う。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T <span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\n&quot;</span>s <span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    print_size<span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    print_size<span class="token operator">&lt;</span><span class="token keyword">double</span> <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token comment">// ポインターへのポインター</span>
    print_size<span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre></div><p>筆者の環境でこのプログラムを実行した結果は以下のようになった。</p> <div class="language- extra-class"><pre class="language-text"><code>8
8
8
</code></pre></div><p>どうやら筆者の環境ではポインターのサイズはすべて8バイトらしい。</p> <h3 id="ポインターの値"><a href="030-pointer-details.html#ポインターの値" class="header-anchor">#</a> ポインターの値</h3> <p>ポインターが8バイト、つまり64ビットの値であるならば、それを8バイトの符号なし整数として解釈した値はどうなるのだろう。</p> <p>C++にはすべてのポインターの値を格納できるサイズの符号なし整数型が用意されている。<code>std::uintptr_t</code>だ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span> std<span class="token operator">::</span>uintptr_t <span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>筆者の環境でこのプログラムを実行した結果も<code>8</code>が出力される。</p> <p>ポインターも<code>std::uintptr_t</code>も8バイトだ。ポインターのバイト列を<code>std::uintptr_t</code>として強引に解釈すれば、符号なし整数としての値を出力してみよう。</p> <p>ある値<code>from</code>のバイト列を、同じバイト数のある型<code>to</code>の値として強引に解釈するC++20で追加された標準ライブラリに、<code>std::bit_cast&lt;to&gt;(from)</code>がある。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bit&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> data <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>bit_cast<span class="token operator">&lt;</span>std<span class="token operator">::</span>uintptr_t<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>このプログラムを何度か実行した結果、以下のような結果を得た。</p> <div class="language- extra-class"><pre class="language-text"><code>$ make run
140725678382588
$ make run
140721510940268
$ make run
140731669632396
</code></pre></div><p>私の環境ではポインターの具体的な値は実行ごとに異なる。これは私の使っているOSがASLR(Address Space Layout Randomization)を実装しているためだ。興味のある読者は調べてみるとよい。</p> <p>この値は<code>int</code>型の変数<code>data</code>のポインターの整数としての値だ。このアドレスの場所に、<code>int</code>型のオブジェクトの最初の1バイトがあり、その次の場所に次の1バイトがある。</p> <p>筆者の環境では<code>int</code>型は4バイトだ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>int</code>型のオブジェクトは4バイトの連続したメモリー上に構築されている。つまり、本質的には以下のようなコードと同等になる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>byte data<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>bit_cast<span class="token operator">&lt;</span>std<span class="token operator">::</span>uintptr_t<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>std::byte</code>というのは<code>sizeof(std::byte)</code>の結果が1になる、サイズが1バイトの符号なし整数型だ。</p> <p><code>std::byte</code>はC++で1バイトの生の値を表現するために使うことができる。配列は連続したバイト列なので、4バイトの<code>int</code>型は、本質的には上のようなコードになる。ただし上のコードはアライメントという概念が欠けている。これについてはあとで説明する。</p> <p>ところで、<code>std::bit_cast</code>は2020年に制定される国際標準規格C++20から入った。しかるに筆者がこの文章を書いているのは2018年だ。まだC++20を完全に実装したC++コンパイラーは存在しない。この本が出版されてしばらくは、読者の手元にもC++20コンパイラーは存在しないだろう。</p> <h3 id="std-bit-castの実装"><a href="030-pointer-details.html#std-bit-castの実装" class="header-anchor">#</a> <code>std::bit_cast</code>の実装</h3> <p>ないものは自分で実装すればいい。<code>std::bit_cast</code>に近いものを実装してみよう。</p> <p>今回実装する<code>bit_cast</code>は以下のような関数テンプレートだ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">typename</span> To<span class="token punctuation">,</span> <span class="token keyword">typename</span> From <span class="token operator">&gt;</span>
To <span class="token function">bit_cast</span><span class="token punctuation">(</span> From <span class="token keyword">const</span> <span class="token operator">&amp;</span> from <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 値fromのバイト列をTo型の値として解釈して返す。</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>bit_cast</code>の実装にはポインターが必要だ。<code>From</code>の値を表現するバイト列への先頭のポインターを取り、バイト単位で<code>To</code>の値を表現するバイト列にコピーすればよい。</p> <p>標準ライブラリにはそのような処理を行ってくれる<code>std::memcpy(dest, src, n)</code>がある。ポインター<code>src</code>から<code>n</code>バイトをポインター<code>dest</code>から<code>n</code>バイトに書き込む関数だ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">typename</span> To<span class="token punctuation">,</span> <span class="token keyword">typename</span> From <span class="token operator">&gt;</span>
To <span class="token function">bit_cast</span><span class="token punctuation">(</span> From <span class="token keyword">const</span> <span class="token operator">&amp;</span> from <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    To to <span class="token punctuation">;</span>
    std<span class="token operator">::</span><span class="token function">memcpy</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>to<span class="token punctuation">,</span> <span class="token operator">&amp;</span>from<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>To<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token keyword">return</span> to <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>これで<code>std::bit_cast</code>の実装はできた。しかしこの実装は問題を<code>std::memcpy</code>にたらい回しにしただけだ。<code>std::memcpy</code>も実装できて初めて<code>std::bit_cast</code>を自前で実装できたと言える。</p> <h3 id="std-memcpyの実装"><a href="030-pointer-details.html#std-memcpyの実装" class="header-anchor">#</a> <code>std::memcpy</code>の実装</h3> <p><code>std::memcpy</code>はC++コンパイラーによって効率のよいコードに置き換えられる。そのため自分で実装した<code>std::memcpy</code>を標準ライブラリと同じ効率にすることは難しいが、機能的にはほとんど同じものを作ることができる。</p> <p><code>memcpy</code>の実装にはポインターの詳細な理解が必要だ。</p> <p><code>std::memcpy</code>関数は以下のようになっている。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">memcpy</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> dest<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token keyword">const</span> <span class="token operator">*</span> src<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t n <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// srcの先頭バイトからnバイトを</span>
    <span class="token comment">// destの先頭バイトからのバイト列にコピーし</span>
    <span class="token comment">// destを返す</span>
<span class="token punctuation">}</span>
</code></pre></div><p>見慣れない<code>void *</code>という型が出てきた。まずはこれについて学ぼう。</p> <h4 id="void型"><a href="030-pointer-details.html#void型" class="header-anchor">#</a> void型</h4> <p><code>void</code>は特別な型だ。<code>void</code>型は何も値を持たない型という意味を持つ。例えば関数が戻り値を何も返さない場合、<code>void</code>型を返す関数として宣言される。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 何も値を返さない関数</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 何も値を返さない</span>
    <span class="token keyword">return</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>あらゆる値は<code>void</code>型に変換することができる。変換した結果は、何も値を持たない。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>C++17では、<code>void</code>型の変数は作れない。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// エラー</span>
<span class="token keyword">void</span> x <span class="token punctuation">;</span>
</code></pre></div><p>ところで、読者が本書を読むころには、C++規格では<code>void</code>型の変数が作れるようになっているかもしれない。これは<code>void</code>型だけ変数を作れないのが面倒だから作れるようになるだけで、具体的な値のない変数になる。</p> <h4 id="void-型"><a href="030-pointer-details.html#void-型" class="header-anchor">#</a> void *型</h4> <p><code>void *</code>型は「<code>void</code>型へのポインター型」だ。<code>int *</code>が「<code>int</code>型へのポインター型」であるのと同じだ。</p> <p><code>void *</code>型の値は、ある型<code>T</code>へのポインター型から型<code>T</code>という情報が消え去ったポインターの値だ。ポインターの値というのはアドレスで、アドレスというのは単なるバイト単位のメモリーを指す整数値だということを学んだ。<code>void *</code>型は特定の型を意味しないポインター型だ。</p> <p>ある型<code>T</code>へのポインター型の値は、<code>void *</code>型に変換できる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> data <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token punctuation">;</span>

    <span class="token comment">// int *からvoid *への変換</span>
    <span class="token keyword">void</span> <span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>data <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>void *</code>型の値<code>e</code>から元の型<code>T</code>へのポインターに変換するには<code>static_cast&lt;T *&gt;(e)</code>が必要だ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> data <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span> void_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>data <span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token operator">*</span> int_ptr <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>void_ptr<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>もし<code>static_cast&lt;T *&gt;(e)</code>の<code>e</code>が<code>T *</code>として妥当なアドレスの値であれば、変換後も正しく動く。</p> <p><code>T const *</code>型は<code>void const *</code>型に変換できる。その逆変換もできる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> data <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span> int_const_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>data <span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token keyword">const</span> <span class="token operator">*</span> void_const_ptr <span class="token operator">=</span> int_const_ptr <span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span> original <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>void_const_ptr<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>ポインター間の型変換で<code>const</code>を消すことはできない。</p> <p><code>memcpy</code>は<code>void *</code>を使うことで、どんなポインターの値でも取れるようにしている。C++にはテンプレートがあるので以下のように宣言してもよいのだが、</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">typename</span> Dest<span class="token punctuation">,</span> <span class="token keyword">typename</span> Src <span class="token operator">&gt;</span>
Dest <span class="token operator">*</span> <span class="token function">memcpy</span><span class="token punctuation">(</span> Dest <span class="token operator">*</span> dest<span class="token punctuation">,</span> Src <span class="token keyword">const</span> <span class="token operator">*</span> src<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t n <span class="token punctuation">)</span> <span class="token punctuation">;</span>
</code></pre></div><p><code>memcpy</code>はC++以前からあるC言語ライブラリなので、こうなっている。</p> <h4 id="std-byte型"><a href="030-pointer-details.html#std-byte型" class="header-anchor">#</a> std::byte型</h4> <p><code>void *</code>型はアドレスだけを意味するポインター型なので、参照することができない。<code>memcpy</code>の実装にはポインターを経由して参照先を1バイトずつ読み書きする必要がある。そのための型として<code>std::byte</code>がある。</p> <p><code>std::byte</code>型は1バイトを表現するための型だ。<code>sizeof(std::byte)</code>の結果は<code>1</code>になる。</p> <p>1バイトというのは10進数で$0 \leqq n \leqq 255$までの値を扱う。</p> <p><code>std::byte</code>はとても厳格に1バイトの符号なし整数として振る舞うので、普通の整数で初期化や代入をすることができない。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// エラー</span>
std<span class="token operator">::</span>byte a <span class="token operator">=</span> <span class="token number">123</span> <span class="token punctuation">;</span>
std<span class="token operator">::</span>byte <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>

<span class="token comment">// これもエラー</span>
a <span class="token operator">=</span> <span class="token number">123</span> <span class="token punctuation">;</span>
</code></pre></div><p><code>std::byte</code>に具体的な値で初期化するには<code>{x}</code>を使う。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>byte a<span class="token punctuation">{</span><span class="token number">123</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre></div><p><code>std::byte</code>に値を代入するには<code>std::byte{x}</code>を使う</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>byte a <span class="token punctuation">;</span>
a <span class="token operator">=</span> std<span class="token operator">::</span>byte<span class="token punctuation">{</span><span class="token number">123</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre></div><p><code>static_cast&lt;std::byte&gt;(x)</code>や<code>std::byte(x)</code>はコンパイルできるが、使ってはならない。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 使ってはならない</span>
std<span class="token operator">::</span>byte a <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>byte<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
std<span class="token operator">::</span>byte b <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
</code></pre></div><p>なぜ使ってはならないかというと、範囲外の値を無理やり変換してしまうからだ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>byte a <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>byte<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
std<span class="token operator">::</span>byte b <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
</code></pre></div><h4 id="配列のメモリー上での表現"><a href="030-pointer-details.html#配列のメモリー上での表現" class="header-anchor">#</a> 配列のメモリー上での表現</h4> <p>配列は要素型を表現するバイト列をメモリー上に連続して配置する。</p> <p>例えば<code>int [3]</code>という配列があり、<code>sizeof(int)</code>が<code>4</code>の場合、全体で12バイトのメモリーが確保される。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> data<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre></div><p>最初の4バイト（0バイト目から3バイトまで）の領域は0番目の要素である<code>data[0]</code>で、その値は<code>1</code>だ。</p> <p>次の4バイト（4バイト目から7バイト目まで）の領域は1番目の要素である<code>data[1]</code>で、その値は<code>2</code>だ。</p> <p>最後の4バイト（8バイト目から11バイト目まで）の領域は2番目の要素である<code>data[2]</code>で、その値は<code>3</code>だ。</p> <div class="language- extra-class"><pre class="language-text"><code>TODO: メモリーの図示

   ↓最初の4バイト
&lt;-----&gt;
□-□-□-□-□-□-□-□-□-□-□-□
        &lt;-----&gt;
       　　↑次の4バイト
                &lt;-----&gt;
                   ↑最後の4バイト
</code></pre></div><p>fig/fig30-01.png</p> <p>実際にアドレスの生の値を出力して確かめてみよう。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 生のアドレスを出力する関数</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">typename</span> T <span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print_raw_address</span><span class="token punctuation">(</span> T ptr <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>bit_cast<span class="token operator">&lt;</span>std<span class="token operator">::</span>uintptr_t<span class="token operator">&gt;</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\n&quot;</span>s <span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> data<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>
    <span class="token function">print_raw_address</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token function">print_raw_address</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token function">print_raw_address</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>このプログラムを筆者の環境で実行すると以下のように出力された。</p> <div class="language- extra-class"><pre class="language-text"><code>140736120015884
140736120015888
140736120015892
</code></pre></div><p>筆者の環境では<code>sizeof(int)</code>は4だ。<code>&amp;data[0]</code>の生のアドレスに4を足した値が<code>&amp;data[1]</code>になっていることがわかる。</p> <h4 id="ポインターと整数の演算"><a href="030-pointer-details.html#ポインターと整数の演算" class="header-anchor">#</a> ポインターと整数の演算</h4> <p>ポインターと整数を加減算することができる。</p> <p>ポインター<code>T *</code>に整数<code>n</code>を足すと、ポインターのアドレスが<code>sizeof(T) * n</code>加算される。この結果、ポインターは要素が配列のように配置された場合に<code>n</code>個先の要素を指すようになる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">typename</span> T <span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print_raw_address</span><span class="token punctuation">(</span> T ptr <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>bit_cast<span class="token operator">&lt;</span>std<span class="token operator">::</span>uintptr_t<span class="token operator">&gt;</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\n&quot;</span>s <span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>

    <span class="token comment">// 0個目の要素へのポインター</span>
    <span class="token keyword">int</span> <span class="token operator">*</span> a0 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>
    <span class="token function">print_raw_address</span><span class="token punctuation">(</span> a0 <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    

    <span class="token comment">// アドレスがsizeof(int) * 3加算される</span>
    <span class="token comment">// a3は3個目の要素へのポインター</span>
    <span class="token keyword">int</span> <span class="token operator">*</span> a3 <span class="token operator">=</span> a0 <span class="token operator">+</span> <span class="token number">3</span> <span class="token punctuation">;</span>
    <span class="token function">print_raw_address</span><span class="token punctuation">(</span> a3 <span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token comment">// アドレスがsizeof(int) * 2減算される。</span>
    <span class="token comment">// a1は1個目の要素へのポインター</span>
    <span class="token keyword">int</span> <span class="token operator">*</span> a1 <span class="token operator">=</span> a3 <span class="token operator">-</span> <span class="token number">2</span> <span class="token punctuation">;</span>
    <span class="token function">print_raw_address</span><span class="token punctuation">(</span> a1 <span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>これを筆者の環境で実行すると以下のように出力された。</p> <div class="language- extra-class"><pre class="language-text"><code>140722117900224
140722117900236
140722117900228
</code></pre></div><p>最初の値が<code>a0</code>, 次の値が<code>a3</code>, 最後の値が<code>a1</code>だ。</p> <p>筆者の環境では<code>sizeof(int)</code>は<code>4</code>だ。すると<code>a3</code>の値は<code>a0</code>の値より12多い値になっているはずだ。実際にそうなっている。<code>a1</code>は<code>a3</code>に対して8少ない値になっているはずだ。実際にそうなっている。</p> <h4 id="いよいよmemcpyの実装"><a href="030-pointer-details.html#いよいよmemcpyの実装" class="header-anchor">#</a> いよいよmemcpyの実装</h4> <p>これまで学んできたことをすべて使い、ようやく<code>memcpy</code>が実装できる。</p> <ol><li><code>dest</code>を<code>std::byte *</code>型に変換する</li> <li><code>src</code>を<code>std::byte const *</code>型に変換する</li> <li><code>src</code>の参照先から<code>n</code>バイトを<code>dest</code>の参照先にコピーする</li> <li><code>dest</code>を返す</li></ol> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">memcpy</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> dest<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token keyword">const</span> <span class="token operator">*</span> src<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t n <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// destをstd::byte *型に変換</span>
    <span class="token keyword">auto</span> d <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>byte <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>dest<span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// srcをstd::byte const *型に変換する</span>
    <span class="token keyword">auto</span> s <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>byte <span class="token keyword">const</span> <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token comment">// srcからnバイトコピーするのでnバイト先のアドレスを得る </span>
    <span class="token keyword">auto</span> last <span class="token operator">=</span> s <span class="token operator">+</span> n <span class="token punctuation">;</span>

    <span class="token comment">// nバイトコピーする</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span> s <span class="token operator">!=</span> last <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token operator">*</span>d <span class="token operator">=</span> <span class="token operator">*</span>s <span class="token punctuation">;</span>
        <span class="token operator">++</span>d <span class="token punctuation">;</span>
        <span class="token operator">++</span>s <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// destを返す</span>
    <span class="token keyword">return</span> dest <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="memcpyの別の実装"><a href="030-pointer-details.html#memcpyの別の実装" class="header-anchor">#</a> memcpyの別の実装</h4> <p>ポインターは<code>operator []</code>に対応している。</p> <p>ポインター<code>p</code>と整数<code>i</code>に対して<code>p[i]</code>と書いたとき、<code>*(p + i)</code>という意味になる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>

    p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">;</span> <span class="token comment">// 0</span>
    p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">;</span> <span class="token comment">// 2</span>

    <span class="token keyword">int</span> <span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>
    p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>memcpy</code>は<code>operator []</code>を使って書くこともできる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">memcpy</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> dest<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token keyword">const</span> <span class="token operator">*</span> src<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t n <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> d <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>byte <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>dest<span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token keyword">auto</span> s <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>std<span class="token operator">::</span>byte <span class="token keyword">const</span> <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span> std<span class="token operator">::</span>size_t i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">!=</span> n <span class="token punctuation">;</span> <span class="token operator">++</span>i <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> dest <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="データメンバーへのポインターの内部実装"><a href="030-pointer-details.html#データメンバーへのポインターの内部実装" class="header-anchor">#</a> データメンバーへのポインターの内部実装</h3> <p>データメンバーへのポインターの整数としての値は少し変わっている。</p> <p>ポインターの生の値は、メモリー上で値を表現しているバイト列の先頭アドレスだ。</p> <p>データメンバーへのポインターは、具体的なクラスのオブジェクトへのポインターやリファレンスがあって初めて意味がある。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">S</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">123</span> <span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> data <span class="token operator">=</span> <span class="token number">123</span> <span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>data <span class="token punctuation">;</span>
    <span class="token comment">// ptr単体で参照できる</span>
    <span class="token keyword">int</span> read1 <span class="token operator">=</span> <span class="token operator">*</span>ptr <span class="token punctuation">;</span>

    S object <span class="token punctuation">;</span>
    <span class="token keyword">int</span> S<span class="token operator">::</span><span class="token operator">*</span> mem_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>S<span class="token operator">::</span>x <span class="token punctuation">;</span>
    <span class="token comment">// objectとmem_ptrの2つで参照できる</span>
    <span class="token keyword">int</span> read2 <span class="token operator">=</span> object<span class="token punctuation">.</span><span class="token operator">*</span>mem_ptr <span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><p>配列が要素型のバイト列を連続して配置したメモリーレイアウトをしているように、クラスもデータメンバーを連続して配置したメモリーレイアウトをしている。</p> <p>たとえば以下のようなクラス<code>Object</code>がある場合、</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Object</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token punctuation">;</span>
    <span class="token keyword">int</span> y <span class="token punctuation">;</span>
    <span class="token keyword">int</span> z <span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre></div><p>このクラスのサイズは<code>sizeof(Object)</code>だ。このクラスは<code>int</code>型のサブオブジェクトを3つ持っているので、そのサイズは少なくとも<code>size(int)*3</code>はある。</p> <p>実際に確かめてみよう。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Object</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token punctuation">;</span>
    <span class="token keyword">int</span> y <span class="token punctuation">;</span>
    <span class="token keyword">int</span> z <span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;sizeof(int): &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\n&quot;</span>s <span class="token punctuation">;</span>

    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;sizeof(Object): &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\n&quot;</span>s <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>このプログラムを筆者の環境で実行すると以下のように出力された。</p> <div class="language- extra-class"><pre class="language-text"><code>sizeof(int): 4
sizeof(Object): 12
</code></pre></div><p><code>int</code>型のサイズが<code>4</code>で、<code>Object</code>型のサイズが<code>12</code>ということは、クラス<code>Object</code>には<code>int</code>型のサブオブジェクトが3つ、隙間なく連続して配置されているということだ。すべてのクラスがこうではないが、今回の私の環境ではそうなっている。</p> <p>全体で12バイトということは、配列<code>int [3]</code>と同じように、最初の4バイトに<code>x</code>, <code>y</code>, <code>z</code>のどれかが、次の4バイトに残りのどちらかが、最後の4バイトに残りが配置されている。</p> <p>データメンバーへのポインターというのは、このクラスのオブジェクトを表現するバイト列の先頭から何バイト目に配置されているかというオフセット値になっている。</p> <p>具体的な値を見てみよう。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">typename</span> T <span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print_raw_address</span><span class="token punctuation">(</span> T ptr <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> bit_cast<span class="token operator">&lt;</span>std<span class="token operator">::</span>uintptr_t<span class="token operator">&gt;</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\n&quot;</span>s <span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">Object</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token punctuation">;</span>
    <span class="token keyword">int</span> y <span class="token punctuation">;</span>
    <span class="token keyword">int</span> z <span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">print_raw_address</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>Object<span class="token operator">::</span>x <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token function">print_raw_address</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>Object<span class="token operator">::</span>y <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token function">print_raw_address</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>Object<span class="token operator">::</span>z <span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>このプログラムを筆者の環境で実行すると以下のように出力される。</p> <div class="language- extra-class"><pre class="language-text"><code>0
4
8
</code></pre></div><p>筆者の環境では、<code>x</code>はクラスの先頭アドレスからオフセット0バイトに、<code>y</code>はオフセット4バイトに、<code>z</code>はオフセット8バイトに配置されているようだ。</p> <p>確かめてみよう。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Object</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">123</span> <span class="token punctuation">;</span>
    <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">456</span> <span class="token punctuation">;</span>
    <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token number">789</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>

    Object object <span class="token punctuation">;</span>

    <span class="token comment">// クラスのオブジェクトの先頭アドレス</span>
    std<span class="token operator">::</span>byte <span class="token operator">*</span> start <span class="token operator">=</span> bit_cast<span class="token operator">&lt;</span>std<span class="token operator">::</span>byte <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>object<span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// オフセット0</span>
    <span class="token keyword">int</span> <span class="token operator">*</span> x <span class="token operator">=</span> bit_cast<span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>start <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// オフセット4</span>
    <span class="token keyword">int</span> <span class="token operator">*</span> y <span class="token operator">=</span> bit_cast<span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>start <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// オフセット8</span>
    <span class="token keyword">int</span> <span class="token operator">*</span> z <span class="token operator">=</span> bit_cast<span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>start <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>

    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>x <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>y <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>z <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>筆者の環境では以下のように出力される</p> <div class="language- extra-class"><pre class="language-text"><code>123456789
</code></pre></div><p>このプログラムの実行結果は環境によって変わる。読者の使っている環境でデータメンバーへのポインターが筆者の環境と同じように実装されているとは限らない。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="029-pointer-syntax.html" class="prev">文法上のポインター</a></span> <span class="next"><a href="031-iterator-operations.html">イテレーター詳細</a>
      →
    </span></p></div> </main></div><div class="global-ui"><SWUpdatePopup></SWUpdatePopup></div></div>
    <script src="assets/js/app.8620998f.js" defer></script><script src="assets/js/2.7009e9ba.js" defer></script><script src="assets/js/35.2cf21250.js" defer></script>
  </body>
</html>
