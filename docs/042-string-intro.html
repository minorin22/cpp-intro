<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>文字列 | 江添亮のC++入門</title>
    <meta name="description" content="">
    <link rel="icon" href="64.png">
    <script>
        MathJax = {
            chtml: {
                matchFontHeight: false
            },
            tex: {
                inlineMath: [['$', '$']]
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>

  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="152.png">
  <meta name="msapplication-TileImage" content="/144.png">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="assets/css/0.styles.17f32d1e.css" as="style"><link rel="preload" href="assets/js/app.8620998f.js" as="script"><link rel="preload" href="assets/js/2.7009e9ba.js" as="script"><link rel="preload" href="assets/js/47.483b5213.js" as="script"><link rel="prefetch" href="assets/js/10.0bc4fb9f.js"><link rel="prefetch" href="assets/js/11.c5d46ffe.js"><link rel="prefetch" href="assets/js/12.cec763ba.js"><link rel="prefetch" href="assets/js/13.85764695.js"><link rel="prefetch" href="assets/js/14.56c0c5a1.js"><link rel="prefetch" href="assets/js/15.ba58285d.js"><link rel="prefetch" href="assets/js/16.663fe3ce.js"><link rel="prefetch" href="assets/js/17.b9e53cc4.js"><link rel="prefetch" href="assets/js/18.468131c1.js"><link rel="prefetch" href="assets/js/19.966431ea.js"><link rel="prefetch" href="assets/js/20.39088cad.js"><link rel="prefetch" href="assets/js/21.f1d2fbe4.js"><link rel="prefetch" href="assets/js/22.53af9436.js"><link rel="prefetch" href="assets/js/23.45c08f75.js"><link rel="prefetch" href="assets/js/24.fec53f63.js"><link rel="prefetch" href="assets/js/25.1c55ab94.js"><link rel="prefetch" href="assets/js/26.97221aa1.js"><link rel="prefetch" href="assets/js/27.ad617385.js"><link rel="prefetch" href="assets/js/28.1d1956f2.js"><link rel="prefetch" href="assets/js/29.bb17ac3f.js"><link rel="prefetch" href="assets/js/3.a3b2b660.js"><link rel="prefetch" href="assets/js/30.3861fe0d.js"><link rel="prefetch" href="assets/js/31.93e5e7a5.js"><link rel="prefetch" href="assets/js/32.7f1f5a03.js"><link rel="prefetch" href="assets/js/33.ba1ef509.js"><link rel="prefetch" href="assets/js/34.63b70d43.js"><link rel="prefetch" href="assets/js/35.2cf21250.js"><link rel="prefetch" href="assets/js/36.93604af5.js"><link rel="prefetch" href="assets/js/37.132be8e6.js"><link rel="prefetch" href="assets/js/38.32a3f051.js"><link rel="prefetch" href="assets/js/39.bab7cf23.js"><link rel="prefetch" href="assets/js/4.3ff2fe10.js"><link rel="prefetch" href="assets/js/40.2cd9628c.js"><link rel="prefetch" href="assets/js/41.24bfe547.js"><link rel="prefetch" href="assets/js/42.39ebe085.js"><link rel="prefetch" href="assets/js/43.4ff95f43.js"><link rel="prefetch" href="assets/js/44.f1a016d7.js"><link rel="prefetch" href="assets/js/45.590d3d64.js"><link rel="prefetch" href="assets/js/46.46b99b9b.js"><link rel="prefetch" href="assets/js/48.65facf6a.js"><link rel="prefetch" href="assets/js/49.2bda166c.js"><link rel="prefetch" href="assets/js/5.7f8f4812.js"><link rel="prefetch" href="assets/js/50.858dc861.js"><link rel="prefetch" href="assets/js/51.a40bec0a.js"><link rel="prefetch" href="assets/js/52.f5dc4f7e.js"><link rel="prefetch" href="assets/js/53.4cfac598.js"><link rel="prefetch" href="assets/js/54.9b6224cf.js"><link rel="prefetch" href="assets/js/55.4fb7a3ba.js"><link rel="prefetch" href="assets/js/56.8a7823a6.js"><link rel="prefetch" href="assets/js/6.af1283dd.js"><link rel="prefetch" href="assets/js/7.401cafeb.js"><link rel="prefetch" href="assets/js/8.44430c93.js"><link rel="prefetch" href="assets/js/9.39e986e2.js">
    <link rel="stylesheet" href="assets/css/0.styles.17f32d1e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="index.html" class="home-link router-link-active"><!----> <span class="site-name">江添亮のC++入門</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="000-preface.html" class="sidebar-link">序</a></li><li><a href="001-intro.html" class="sidebar-link">C++の概要</a></li><li><a href="002-build.html" class="sidebar-link">C++の実行</a></li><li><a href="003-guide-to-c++.html" class="sidebar-link">C++ヒッチハイクガイド</a></li><li><a href="004-debug-compile-error.html" class="sidebar-link">デバッグ：コンパイルエラーメッセージの読み方</a></li><li><a href="005-the-restaurant-at-the-end-of-the-branch.html" class="sidebar-link">条件分岐の果てのレストラン</a></li><li><a href="006-debug-compile-warning.html" class="sidebar-link">デバッグ: コンパイル警告メッセージ</a></li><li><a href="007-standard-input.html" class="sidebar-link">最近体重が気になるあなたのための標準入力</a></li><li><a href="008-loop.html" class="sidebar-link">ループ</a></li><li><a href="009-vector.html" class="sidebar-link">メモリーを無限に確保する</a></li><li><a href="010-debug-printf.html" class="sidebar-link">デバッグ：printfデバッグ</a></li><li><a href="011-integer.html" class="sidebar-link">整数</a></li><li><a href="012-floating-point.html" class="sidebar-link">浮動小数点数</a></li><li><a href="013-names.html" class="sidebar-link">名前</a></li><li><a href="014-iterator.html" class="sidebar-link">イテレーターの基礎</a></li><li><a href="015-reference.html" class="sidebar-link">lvalueリファレンスとconst</a></li><li><a href="016-algorithm.html" class="sidebar-link">アルゴリズム</a></li><li><a href="017-lambda.html" class="sidebar-link">ラムダ式</a></li><li><a href="018-class.html" class="sidebar-link">クラスの基本</a></li><li><a href="019-operator-overloading.html" class="sidebar-link">より自然に振る舞うクラス</a></li><li><a href="020-array.html" class="sidebar-link">std::array</a></li><li><a href="021-three-virtues-of-a-programmer.html" class="sidebar-link">プログラマーの三大美徳</a></li><li><a href="022-implement-array.html" class="sidebar-link">配列</a></li><li><a href="023-template.html" class="sidebar-link">テンプレート</a></li><li><a href="024-more-array.html" class="sidebar-link">arrayをさらに実装</a></li><li><a href="025-array-iterator.html" class="sidebar-link">arrayのイテレーター</a></li><li><a href="026-exception.html" class="sidebar-link">傲慢なエラー処理: 例外</a></li><li><a href="027-pointer.html" class="sidebar-link">ポインター</a></li><li><a href="028-pointer-semantics.html" class="sidebar-link">意味上のポインター</a></li><li><a href="029-pointer-syntax.html" class="sidebar-link">文法上のポインター</a></li><li><a href="030-pointer-details.html" class="sidebar-link">ポインターの内部実装</a></li><li><a href="031-iterator-operations.html" class="sidebar-link">イテレーター詳細</a></li><li><a href="032-memory-allocation.html" class="sidebar-link">動的メモリー確保</a></li><li><a href="033-vector-implementation.html" class="sidebar-link">vectorの実装 : 基礎</a></li><li><a href="034-vector-memory-allocation.html" class="sidebar-link">vectorの実装 : メモリー確保</a></li><li><a href="035-copy.html" class="sidebar-link">コピー</a></li><li><a href="036-move.html" class="sidebar-link">ムーブ</a></li><li><a href="037-rvalue-reference.html" class="sidebar-link">rvalueリファレンス</a></li><li><a href="038-move-semantics.html" class="sidebar-link">ムーブの実装</a></li><li><a href="039-disable-copy.html" class="sidebar-link">コピーの禁止</a></li><li><a href="040-smart-pointer.html" class="sidebar-link">スマートポインター</a></li><li><a href="041-move-support.html" class="sidebar-link">自作の数値クラスで演算をムーブに対応する方法</a></li><li><a href="042-string-intro.html" class="active sidebar-link">文字列</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="042-string-intro.html#はじめに" class="sidebar-link">はじめに</a></li><li class="sidebar-sub-header"><a href="042-string-intro.html#基本ソース文字セット" class="sidebar-link">基本ソース文字セット</a></li><li class="sidebar-sub-header"><a href="042-string-intro.html#基本実行文字セット" class="sidebar-link">基本実行文字セット</a></li><li class="sidebar-sub-header"><a href="042-string-intro.html#文字を表現する方法" class="sidebar-link">文字を表現する方法</a></li><li class="sidebar-sub-header"><a href="042-string-intro.html#os" class="sidebar-link">OS</a></li><li class="sidebar-sub-header"><a href="042-string-intro.html#リテラル" class="sidebar-link">リテラル</a></li><li class="sidebar-sub-header"><a href="042-string-intro.html#ワイド文字" class="sidebar-link">ワイド文字</a></li><li class="sidebar-sub-header"><a href="042-string-intro.html#utf-8-utf-16-utf-32" class="sidebar-link">UTF-8/UTF-16/UTF-32</a></li><li class="sidebar-sub-header"><a href="042-string-intro.html#生文字列リテラル" class="sidebar-link">生文字列リテラル</a></li><li class="sidebar-sub-header"><a href="042-string-intro.html#文字列の表現方法" class="sidebar-link">文字列の表現方法</a></li><li class="sidebar-sub-header"><a href="042-string-intro.html#文字列の操作" class="sidebar-link">文字列の操作</a></li></ul></li><li><a href="043-random.html" class="sidebar-link">乱数</a></li><li><a href="044-random-part2.html" class="sidebar-link">ポアソン分布</a></li><li><a href="045-random-part3.html" class="sidebar-link">正規分布</a></li><li><a href="046-random-part4.html" class="sidebar-link">サンプリング分布(sampling distributions)</a></li><li><a href="200-cpp.html" class="sidebar-link">Cプリプロセッサー</a></li><li><a href="300-multiple-source-files.html" class="sidebar-link">分割コンパイル</a></li><li><a href="400-gdb.html" class="sidebar-link">デバッガー</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="文字列"><a href="042-string-intro.html#文字列" class="header-anchor">#</a> 文字列</h1> <h2 id="はじめに"><a href="042-string-intro.html#はじめに" class="header-anchor">#</a> はじめに</h2> <p>とうとう文字列を学ぶべきときがやってきた。文字列自体は最初から使ってきた。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> s <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span>s <span class="token punctuation">;</span>
</code></pre></div><p>これは文字列の表面的な使い方だけだ。しかも、本書ではこれまで文字列に日本語を使ってこなかった。これには理由がある。たとえば、</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;こんにちは&quot;</span>s <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>のようなコードが動くかどうかは実装依存だからだ。試しにコンパイルして実行してみよう。もし画面に「こんにちは」と表示されたのであれば、どうやら読者の環境はこのコードで日本語を出力、表示できるようだ。</p> <h2 id="基本ソース文字セット"><a href="042-string-intro.html#基本ソース文字セット" class="header-anchor">#</a> 基本ソース文字セット</h2> <p>C++では、基本ソース文字セットと呼ばれる文字がある。C++のソースコードで安全に使うことができる文字だ。ラテンアルファベットの大文字小文字、記号、制御文字からなる文字セットで、96文字ある。</p> <p>空白文字、水平タブ、垂直タブ、フォームフィード、改行の5文字と、印字可能な以下の91文字だ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>a b c d e f g h i j k l m n o p q r s t u v w x y z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
<span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span>
_ <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span> # <span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token operator">&gt;</span> <span class="token operator">%</span> <span class="token operator">:</span> <span class="token punctuation">;</span> <span class="token punctuation">.</span> <span class="token operator">?</span> <span class="token operator">*</span> <span class="token operator">+</span> <span class="token operator">-</span> <span class="token operator">/</span> <span class="token operator">^</span> <span class="token operator">&amp;</span> <span class="token operator">|</span> <span class="token operator">~</span> <span class="token operator">!</span> <span class="token operator">=</span> <span class="token punctuation">,</span> \ &quot; '
</code></pre></div><h2 id="基本実行文字セット"><a href="042-string-intro.html#基本実行文字セット" class="header-anchor">#</a> 基本実行文字セット</h2> <p>基本実行文字セットは基本ソース文字セットにアラート、バックスペース、キャリッジリターン、null文字を加えたものだ。</p> <p>null文字は整数の<code>0</code>に等しいという特別な特徴を持つ文字だ。</p> <h2 id="文字を表現する方法"><a href="042-string-intro.html#文字を表現する方法" class="header-anchor">#</a> 文字を表現する方法</h2> <p>文字をコンピューターで扱うには、ビット列で文字を表現できなければならない。C++でアドレス可能な最小単位はバイトなので、文字というのはバイト列で表現する。</p> <h3 id="ascii"><a href="042-string-intro.html#ascii" class="header-anchor">#</a> ASCII</h3> <p>ASCIIはとても広く普及した文字のエンコード方法だ。ASCIIでは7ビットの整数値で1文字を表現する。</p> <p>C++の基本実行文字セットは特定の文字エンコードであると規定されてはいないが、ASCIIを参考にしている。ただしASCIIには基本実行文字セットにはない、ダラーサイン($)、アットマーク(@)、バッククオート(`)といくつかの制御文字がある。</p> <h3 id="unicode"><a href="042-string-intro.html#unicode" class="header-anchor">#</a> Unicode</h3> <p>Unicode、もしくはISO/IEC 10646(Universal Coded Character Set, UCS)は文字のコードポイントを定める規格だ。</p> <p>Unicodeは当初、16bitの符号なし整数値でコードポイントを表現する規格であった。この当時、1コードポイントは1文字であり16bitであった。</p> <p>そのような当初の目論見はすぐに破綻し、いまでは1コードポイントは21bit弱(U+0000からU+10FFFF)であり、1コードポイントは1文字を意味しないようになった。複数のコードポイントを組み合わせて1文字が表現されることもあるからだ。</p> <p>Unicodeはコードポイントについて定めた規格であり、バイト列で文字を表現する規格ではない。Unicodeを元にしたバイト列によって文字を表現するエンコード方式に、UTF-8, UTF-16, UTF-32が存在する。</p> <h4 id="utf-16"><a href="042-string-intro.html#utf-16" class="header-anchor">#</a> UTF-16</h4> <p>UTF-16は16bitの符号なし整数値によってUnicodeのコードポイントを表現するエンコード方式だ。まだUnicodeが16bitのコードポイントですべての文字を表現すると考えていたころに考案されたUCS-2が元になっている。</p> <p>その後、Unicodeのコードポイントが21bit弱に拡張されたので、UCS-2からUTF-16が考案された。</p> <p>UTF-16は16bitを1単位とした符号なし整数で21bit弱のコードポイントを表現するために、1単位で表現できないコードポイントを、サロゲートペアと呼ばれる連続した2単位で表現する。</p> <p>そのため、UTF-16の任意の1単位を切り出すと、それは1つのコードポイントを表現するサロゲートペアの片方である可能性があり、文字として壊れてしまう可能性がある。</p> <h4 id="utf-32"><a href="042-string-intro.html#utf-32" class="header-anchor">#</a> UTF-32</h4> <p>UTF-32は32bitの符号なし整数値によってUnicodeのコードポイントを表現するエンコード方式だ。UTF-32の1単位は32bit符号なし整数なので、Unicodeの任意の1コードポイントを表現できる。</p> <p>ただし問題は、Unicodeではもはや1コードポイントは1文字ではないということだ。したがってUTF-32の1単位は1文字ではない。</p> <p>UTF-32の1単位は1コードポイントだが、UTF-32の任意の1単位を切り出すことはできない。</p> <p>連続した複数のコードポイントによって表現された1文字が壊れる可能性があるからだ。</p> <h4 id="エンディアンの問題"><a href="042-string-intro.html#エンディアンの問題" class="header-anchor">#</a> エンディアンの問題</h4> <p>UTF-16とUTF-32は1単位が複数のバイトからなるエンコード方式だ。複数バイトからなる整数にはエンディアン(Endian)の問題がある。</p> <p>エンディアンとは複数の連続したバイト列の順序のことだ。</p> <p>1バイトが8bitの環境で2バイトの符号なし整数を考えよう。C++には16bit符号なし整数型である<code>std::uint16_t</code>がある。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span><span class="token keyword">uint16_t</span> value <span class="token operator">=</span> <span class="token number">0b00000001'00000010</span> <span class="token punctuation">;</span>
</code></pre></div><p>2バイトの符号なし整数である<code>value</code>の2つの連続したバイトの上位桁を表現するバイトを上位バイト、下位桁を表現するバイトを下位バイトと呼ぶ。上のコードは上位バイトに1、下位バイトに2が表現されている。このバイト列を直接見てみよう。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// byte表示用の関数</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span> std<span class="token operator">::</span>byte x <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span> 

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 上位バイトに1</span>
    <span class="token comment">// 下位バイトに2</span>
    std<span class="token operator">::</span><span class="token keyword">uint16_t</span> value <span class="token operator">=</span> <span class="token number">0b00000001'00000010</span> <span class="token punctuation">;</span>

    <span class="token comment">// 2バイトの配列</span>
    std<span class="token operator">::</span>byte rep<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>

    <span class="token comment">// バイト列をコピー</span>
    std<span class="token operator">::</span><span class="token function">memcpy</span><span class="token punctuation">(</span> rep<span class="token punctuation">,</span> <span class="token operator">&amp;</span>value<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token comment">// 上位バイト</span>
    <span class="token function">print</span><span class="token punctuation">(</span> rep<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// 下位バイト</span>
    <span class="token function">print</span><span class="token punctuation">(</span> rep<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>筆者の環境では<code>&quot;21&quot;</code>と表示される。これはつまり、2つのバイトのうち、下位バイトの方が先に配置されているということだ。</p> <p>世の中にはリトルエンディアン(Little Endian)とビッグエンディアン(Big Endian)がある。これは複数バイトの順序の違いだ。</p> <p>リトルエンディアンは下位バイトから配置する。</p> <p>ビッグエンディアンは上位バイトから配置する。</p> <p>リトルエンディアン環境では、上のプログラムは<code>&quot;21&quot;</code>と表示する。ビッグエンディアン環境では、<code>&quot;12&quot;</code>と表示する。</p> <p>エンディアンの存在により、UTF-16とUTF-32は2つのバイト列表現が存在することになる。</p> <h4 id="utf-8"><a href="042-string-intro.html#utf-8" class="header-anchor">#</a> UTF-8</h4> <p>UTF-8は最も後発のUnicodeのコードポイントの文字エンコードだ。</p> <p>UTF-8は8bitを1単位とし、1単位から4単位までの連続した単位列によってUnicodeの1コードポイントを表現する。</p> <p>UTF-8が1単位だけでコードポイントを表現するとき、下位7bitはASCIIの文字の値に等しい。その点でUTF-8はASCIIと互換性がある。</p> <p>これにより従来ASCIIを使っていたコードやシステムとの親和性が高く、普及した。</p> <p>UTF-8は現在最も普及している文字コードだ。</p> <h2 id="os"><a href="042-string-intro.html#os" class="header-anchor">#</a> OS</h2> <p>C++プログラムが実行できるOSとしては以下のようなものがある。</p> <ul><li>GNU/Linux</li> <li>Android</li> <li>FreeBSD</li> <li>DragonflyBSD</li> <li>OpenBSD</li> <li>NetBSD</li> <li>Apple macOS</li> <li>Apple iOS</li> <li>Microsoft Windows</li></ul> <p>このほかにもOSはさまざまあるが、情報を得るだけでもNDAを結ぶ必要がある表に出てこないOSであったり、実験的すぎたりして、C++を学習する環境としては不適切だ。</p> <p>このうち、Microsoft Windowsを除くOSはUTF-8を使用している。</p> <p>Microsoft WindowsはUTF-16を使用している。ただし、この状況はMicrosoft Windowsは最近UTF-8ロケールを実装したので将来的に変わるだろう。</p> <h2 id="リテラル"><a href="042-string-intro.html#リテラル" class="header-anchor">#</a> リテラル</h2> <h3 id="通常の文字リテラル"><a href="042-string-intro.html#通常の文字リテラル" class="header-anchor">#</a> 通常の文字リテラル</h3> <p>通常の文字リテラルは単一引用符で1つの文字を囲む。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token string">'a'</span>
<span class="token string">'b'</span>
<span class="token string">'c'</span>
</code></pre></div><p>通常の文字リテラルの型は<code>char</code>だ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token punctuation">;</span>
<span class="token keyword">char</span> b <span class="token operator">=</span> <span class="token string">'b'</span> <span class="token punctuation">;</span>
<span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token string">'c'</span> <span class="token punctuation">;</span>
</code></pre></div><p>文字リテラルには以下のようなエスケープシーケンスがある。これは一部の印字不可能な文字や、文法上の理由で直接リテラルの中に書くことができない文字を書けるようにするための代替手段だ。</p> <p>意味                    リテラル</p> <hr> <p>改行                    <code>\n</code>
水平タブ                <code>\t</code>
垂直タブ                <code>\v</code>
バックスペース          <code>\b</code>
キャリッジリターン      <code>\r</code>
フォームフィード        <code>\f</code>
アラート                <code>\a</code>
バックスラッシュ        <code>\\</code>
疑問符                  <code>\?</code>
単一引用符              <code>\'</code>
二重引用符              <code>\&quot;</code></p> <p>これを使えば、単一引用符の文字リテラルは</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token string">'\''</span> <span class="token punctuation">;</span>
</code></pre></div><p>と書ける。エスケープシーケンスにはバックスラッシュを使うため、文字リテラルのなかでバックスラッシュを使うには、エスケープシーケンスが必要だ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token string">'\\'</span> <span class="token punctuation">;</span>
</code></pre></div><p>通常の文字がどのような文字エンコードを使っているかは実装定義だ。</p> <p>そのほかにも文字の数値を直接指定するエスケープシーケンスとして、8進数エスケープシーケンスと16進数エスケープシーケンスがある。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">char</span> oct <span class="token operator">=</span> <span class="token string">'\101'</span> <span class="token punctuation">;</span>
<span class="token keyword">char</span> hex <span class="token operator">=</span> <span class="token string">'\x41'</span> <span class="token punctuation">;</span>
</code></pre></div><p>このコードは、8進数で<code>101</code>、16進数で<code>41</code>になる何らかの文字を表現している。もし通常の文字リテラルがASCIIかUTF-8でエンコードされている場合、この文字は<code>A</code>になる。</p> <h3 id="ユニバーサルキャラクター名"><a href="042-string-intro.html#ユニバーサルキャラクター名" class="header-anchor">#</a> ユニバーサルキャラクター名</h3> <p>文字リテラルには特殊なエスケープシーケンスであるユニバーサルキャラクター名(Universal Character name)を使うことができる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>\uNNNN
\UNNNNNNNNN
</code></pre></div><p>文法は<code>\u</code>に続いて16進数を4文字書くとこれはUnicodeコードポイントにおける<code>U+0000NNNN</code>になる。<code>\U</code>に続いて16進数を8文字書くと、これはUnicodeコードポイントにおける<code>U+NNNNNNNN</code>になる。</p> <h3 id="通常の文字列リテラル"><a href="042-string-intro.html#通常の文字列リテラル" class="header-anchor">#</a> 通常の文字列リテラル</h3> <p>通常の文字列リテラルは二重引用符で文字列を囲む。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token string">&quot;abc&quot;</span> <span class="token punctuation">;</span>
<span class="token string">&quot;hello&quot;</span> <span class="token punctuation">;</span>
<span class="token string">&quot;This is a pen.&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>通常の文字列リテラルの型は<code>const</code>な文字型の配列になる。具体的な型としては<code>const char [n]</code>になる。<code>n</code>は文字列のサイズだ。通常の文字列リテラルの中の文字が基本実行文字だけであれば、書かれている文字数+1になる。しかし、この文字数というのも難しい。</p> <p>文字列リテラルが連続している場合、1つにまとめられる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> s <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span> <span class="token string">&quot;def&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>というコードは、</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> s <span class="token operator">=</span> <span class="token string">&quot;abcdef&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>と書くのと同じだ。</p> <p>文字列リテラルの中のエスケープシーケンスは対応する文字になる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token string">&quot;\n&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>という通常の文字列リテラルは、バックスラッシュとラテンアルファベットnではなく、改行文字1文字になる。</p> <p>通常の文字列リテラルは末尾にnull文字(<code>\0</code>)が付与される。このために、配列のサイズは文字数+1になる。</p> <p>具体的な例では、<code>&quot;abc&quot;</code>という通常の文字列リテラルの型は<code>const char [4]</code>になる。これは以下のような配列に等しい。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre></div><p><code>&quot;hello&quot;</code>の型は<code>const char [6]</code>になる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'\0'</span> <span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre></div><p><code>char</code>型の配列の初期化に通常の文字列リテラルを使うことができる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>配列の添字を書かない場合、文字列リテラルのサイズになる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// char [6]</span>
<span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>また、文字列リテラルは配列であるので、先頭要素へのポインターに暗黙に型変換される。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>文字列リテラルを<code>auto</code>で変数の初期化子に書くと、型はポインターになる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// const char *</span>
<span class="token keyword">auto</span> pointer <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p><code>decltype(auto)</code>という<code>auto</code>と似ているがあまり暗黙の型変換を行わない別のキーワードを使うと、配列へのリファレンス型になる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// const char (&amp;) [6]</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> reference <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><h2 id="ワイド文字"><a href="042-string-intro.html#ワイド文字" class="header-anchor">#</a> ワイド文字</h2> <p>ワイド文字リテラルとワイド文字列リテラルはリテラルにエンコードプレフィクス<code>L</code>を付ける。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// ワイド文字リテラル</span>
L<span class="token string">'A'</span> <span class="token punctuation">;</span>
<span class="token comment">// ワイド文字列リテラル</span>
L<span class="token string">&quot;hello&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>ワイド文字リテラルの型は<code>wchar_t</code>、ワイド文字列リテラルの型は<code>const wchar_t [n]</code>になる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">wchar_t</span> c <span class="token operator">=</span> L<span class="token string">'A'</span> <span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">wchar_t</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>ref<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token string">&quot;hello&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>ワイド文字は失敗した機能だ。まだUnicodeが16bitで世界中の文字を表現できるという妄想にとらわれていたころに提案された時代遅れの実装不可能な機能だ。</p> <p>C++の規格では、「ワイド文字は<code>wchar_t</code>型のオブジェクト1つがシステムがサポートする任意の1文字を表現可能である」と規定している。そのような文字エンコード方式はいまだかつて存在していない。Unicodeの1コードポイントは1文字を意味しないので、UTF-32を使ってもワイド文字の規定を満たすことはできない。そのため、現在規格準拠の方法でワイド文字を実装しているC++コンパイラーは存在しない。</p> <p>Microsoft Windowsはワイド文字をUTF-16で表現している。それ以外の主要なOSはUTF-32を使っている。</p> <h2 id="utf-8-utf-16-utf-32"><a href="042-string-intro.html#utf-8-utf-16-utf-32" class="header-anchor">#</a> UTF-8/UTF-16/UTF-32</h2> <p>UTF-8の文字型は<code>char8_t</code>でエンコードプレフィクスは<code>u8</code>。</p> <p>UTF-16の文字型は<code>char16_t</code>でエンコードプレフィクスは<code>u</code>。</p> <p>UTF-32の文字型は<code>char32_t</code>でエンコードプレフィクスは<code>U</code>。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>char8_t  utf8   <span class="token operator">=</span> u8<span class="token string">'a'</span> <span class="token punctuation">;</span>
<span class="token keyword">char16_t</span> utf16  <span class="token operator">=</span> u<span class="token string">'あ'</span> <span class="token punctuation">;</span>
<span class="token keyword">char32_t</span> utf32  <span class="token operator">=</span> U<span class="token string">'あ'</span> <span class="token punctuation">;</span>
</code></pre></div><p>UTF-8文字型である<code>char8_t</code>はUTF-8の1単位なので、UTF-8の1単位で表現できる文字しか表現できない。</p> <p>UTF-8/UTF-16/UTF-32の文字列リテラルは、それぞれの<code>const</code>な文字型の配列になる。エンコードプレフィクスは文字リテラルと同じだ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// char8_t [6]</span>
char8_t s1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> u8<span class="token string">&quot;hello&quot;</span> <span class="token punctuation">;</span>
<span class="token comment">// char16_t [6]</span>
<span class="token keyword">char16_t</span> s2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token string">&quot;hello&quot;</span> <span class="token punctuation">;</span>
<span class="token comment">// char32_t [6]</span>
<span class="token keyword">char32_t</span> s3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> U<span class="token string">&quot;hello&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p><code>&quot;いろは&quot;</code>をそれぞれの文字列リテラルで表現すると以下のようになる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// char8_t [10]</span>
char8_t s1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> u8<span class="token string">&quot;いろは&quot;</span> <span class="token punctuation">;</span>
<span class="token comment">// char16_t [4]</span>
<span class="token keyword">char16_t</span> s2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token string">&quot;いろは&quot;</span> <span class="token punctuation">;</span>
<span class="token comment">// char32_t [4]</span>
<span class="token keyword">char32_t</span> s3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> U<span class="token string">&quot;いろは&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>これは以下のように書くのと同じだ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>char8_t s1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0xe3</span><span class="token punctuation">,</span> <span class="token number">0x81</span><span class="token punctuation">,</span> <span class="token number">0x84</span><span class="token punctuation">,</span> <span class="token number">0xe3</span><span class="token punctuation">,</span> <span class="token number">0x82</span><span class="token punctuation">,</span> <span class="token number">0x8d</span><span class="token punctuation">,</span> <span class="token number">0xe3</span><span class="token punctuation">,</span> <span class="token number">0x81</span><span class="token punctuation">,</span> <span class="token number">0xaf</span><span class="token punctuation">,</span> <span class="token number">0x0</span> <span class="token punctuation">}</span> <span class="token punctuation">;</span>
<span class="token keyword">char16_t</span> s2<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0x3044</span><span class="token punctuation">,</span> <span class="token number">0x308d</span><span class="token punctuation">,</span> <span class="token number">0x306f</span><span class="token punctuation">,</span> <span class="token number">0x0</span> <span class="token punctuation">}</span> <span class="token punctuation">;</span>
<span class="token keyword">char32_t</span> s3<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0x3044</span><span class="token punctuation">,</span> <span class="token number">0x308d</span><span class="token punctuation">,</span> <span class="token number">0x306f</span><span class="token punctuation">,</span> <span class="token number">0x0</span> <span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre></div><p>文字<code>'い'</code>のUnicodeコードポイントは<code>U+3044</code>で、これはUTF-16/UTF-32では1単位で表現できるが、UTF-8では3単位で<code>0xe3, 0x81, 0x84</code>のように表現する。</p> <p>臼(うす U+81FC)の別字である𦥑(うす U+26951)のコードポイントは16bit符号なし整数で表現できないので、UTF-16ではサロゲートペアを使って2単位表現される。UTF-8では4単位を使って表現される。</p> <p>以下のコードは、</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>char8_t  s1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> u8<span class="token string">&quot;𦥑&quot;</span> <span class="token punctuation">;</span>
<span class="token keyword">char16_t</span> s2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token string">&quot;𦥑&quot;</span> <span class="token punctuation">;</span>
<span class="token keyword">char32_t</span> s3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> U<span class="token string">&quot;𦥑&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>以下のように解釈される。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>char8_t s1<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0xf0</span><span class="token punctuation">,</span> <span class="token number">0xa6</span><span class="token punctuation">,</span> <span class="token number">0xa5</span><span class="token punctuation">,</span> <span class="token number">0x91</span><span class="token punctuation">,</span> <span class="token number">0x0</span> <span class="token punctuation">}</span> <span class="token punctuation">;</span>
<span class="token keyword">char16_t</span> s2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0xd85a</span><span class="token punctuation">,</span> <span class="token number">0xdd51</span><span class="token punctuation">,</span> <span class="token number">0x0</span> <span class="token punctuation">}</span> <span class="token punctuation">;</span>
<span class="token keyword">char32_t</span> s3<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0x26951</span><span class="token punctuation">,</span> <span class="token number">0x0</span> <span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre></div><p>文字<code>'が'</code>はUnicodeコードポイントでは結合済みコードポイントの<code>U+304C</code>で表現できるが、コードポイントU+304B(HIRAGANA LETTER KA)のあとに直ちに続いて、コードポイントU+3099(COMBINING KATAKANA-HIRAGANA VOICED SOUND MARK)を使って表現してもよい。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// u8&quot;\u304C&quot;</span>
char8_t ga1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> u8<span class="token string">&quot;が&quot;</span> <span class="token punctuation">;</span>
<span class="token comment">// u8&quot;\u304B\u3099&quot;</span>
char8_t ga2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> u8<span class="token string">&quot;か\u3099&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>これは以下のコードと等しい。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>char8_t ga1<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0xe3</span><span class="token punctuation">,</span> <span class="token number">0x81</span><span class="token punctuation">,</span> <span class="token number">0x8c</span><span class="token punctuation">,</span> <span class="token number">0x0</span> <span class="token punctuation">}</span> <span class="token punctuation">;</span>
char8_t ga2<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0xe3</span><span class="token punctuation">,</span> <span class="token number">0x81</span><span class="token punctuation">,</span> <span class="token number">0x8b</span><span class="token punctuation">,</span> <span class="token number">0xe3</span><span class="token punctuation">,</span> <span class="token number">0x82</span><span class="token punctuation">,</span> <span class="token number">0x99</span><span class="token punctuation">,</span> <span class="token number">0x0</span> <span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre></div><p>変数<code>ga1, ga2</code>はどちらもUnicodeとして正しい「が」という1文字の表現だ。Unicodeでは複数のコードポイントで1文字を表現することもあるし、意味的に表示的に同じ文字に対して複数の表現方法がある。</p> <p>Apple macOSはUnicodeの正規化として一般的なNFC(Canonical Composition)ではなくNormalization Form D(NFD)を使っているので、濁点や半濁点は必ず分解される。Apple macOSでは<code>u8&quot;\u304B\u3099&quot;</code>が一般的な表現で、それ以外の環境では<code>u8&quot;\u304C&quot;</code>が一般的な表現だ。しかし、どちらも意味上は同じ表現だ。</p> <p>Unicodeの奇妙で面白い例は枚挙に暇がない。ここでは日本語を扱う際によくある注意点を説明したが、ほかにも絵文字、デーヴァナーガリー（ヒンディー語、マラーティー語、ネパール語）、モンゴル文字、アラビア文字、ヘブライ文字など扱いの難しい文字がたくさんある。</p> <p>重要な点をまとめると、</p> <ul><li>文字型の1つのオブジェクトは1文字ではない</li> <li>1コードポイントは1文字ではない</li></ul> <h2 id="生文字列リテラル"><a href="042-string-intro.html#生文字列リテラル" class="header-anchor">#</a> 生文字列リテラル</h2> <p>エスケープシーケンスは文法上の理由で直接ソースコード上に記述することができない文字を文字リテラルと文字列リテラルに記述できる機能だ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>u8<span class="token string">&quot;\nは改行文字&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>しかしエスケープシーケンスがあるために、バックスラッシュを普通に使うには、<code>\\</code>と書かなければならない。例えば上の文字列リテラルを改行文字に続いて「は改行文字」ではなく、本当に「<code>\n</code>は改行文字」という文字列にしたい場合、以下のように書かなければならない。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>u8<span class="token string">&quot;\\nは改行文字&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>また、単一引用符<code>'</code>や二重引用符<code>&quot;</code>もエスケープシーケンスが必要だ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>u8<span class="token string">&quot;\'は単一引用符&quot;</span> <span class="token punctuation">;</span>
u8<span class="token string">&quot;\&quot;は二重引用符&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>また、以下のような内容の文字列をリテラルとして書きたい場合、</p> <div class="language- extra-class"><pre class="language-text"><code>foo
bar
baz
</code></pre></div><p>以下のように書かなければならない。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token string">&quot;foo\nbar\nbaz&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>このようなわかりにくい記述ではなく、ソースコードに書いたままの文字列を文字列として扱いたい。そのための機能が生文字列リテラル(Raw String Literal)だ。</p> <p>生文字列リテラルは以下のような文法で書く。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token raw-string string">R&quot;(...)&quot;</span>
</code></pre></div><p>例えば以下のように書くと、</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token raw-string string">R&quot;(foo
bar
baz)&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>以下のような文字列リテラルと同じ意味になる。</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;foo\nbar\nbaz&quot; ;
</code></pre></div><p>エスケープシーケンスも書いたままに文字列となる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token raw-string string">R&quot;(
'は単一引用符
&quot;は二重引用符
\nは改行文字
)&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>これは以下の文字列リテラルと同じ意味だ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token string">&quot;\n\'は単一引用符\n\&quot;は二重引用符\n\\nは改行文字\n&quot;</span>
</code></pre></div><h2 id="文字列の表現方法"><a href="042-string-intro.html#文字列の表現方法" class="header-anchor">#</a> 文字列の表現方法</h2> <p>文字列というのは文字型の配列で表現される。文字列を表現するには、配列の先頭へのポインターと配列のサイズが必要になる。</p> <h3 id="null終端文字列"><a href="042-string-intro.html#null終端文字列" class="header-anchor">#</a> null終端文字列</h3> <p>C++の文字列リテラルは、末尾にnull文字が付与された<code>const</code>な文字型への配列だ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token string">&quot;abc&quot;</span> <span class="token punctuation">;</span>
</code></pre></div><p>という文字列リテラルは型とその値としては</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">char</span> st<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'\0'</span> <span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre></div><p>になる。</p> <p>null終端文字列とはC言語から使われている文字列の表現方法だ。文字型の配列の末尾にnull文字を番兵として配置することで文字列の終端を表現している。C言語では文字列は文字型へのポインターとして表現される。ポインターが指す配列のサイズはわからないが、妥当な文字列はnull終端されているので、ポインターをインクリメントしていけばいずれnull文字が現れる。そこが文字列の終わりだ。これによって文字列のサイズもわかる。</p> <p>例えば、以下はC言語でよく書かれる典型的文字列を処理する関数だ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">process_string</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> str <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// strが指す配列のサイズを取得</span>
    <span class="token keyword">auto</span> str_size <span class="token operator">=</span> std<span class="token operator">:</span><span class="token function">strlen</span><span class="token punctuation">(</span> str <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// 残りの処理</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>std::strlen</code>はポインターが指し示すnull終端された配列のnull文字を除くサイズを返す。以下のような実装だ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>size_t <span class="token function">strlen</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> i <span class="token operator">=</span> s <span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">*</span>i <span class="token operator">!=</span> <span class="token string">'\0'</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span> <span class="token operator">++</span>i <span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">return</span> i <span class="token operator">-</span> s <span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre></div><p>ここで言う「文字列のサイズ」とは、ポインターが指し示す文字型の配列の要素数であって、文字数ではない。</p> <p>null終端文字列は文字型へのポインター1つだけなので取り回しがよい。ただし、文字列のサイズは実行時に文字列の先頭から末尾までイテレートして計算しなければならない。これは文字列の長さに比例したオーダー$O(N)$の処理量がかかる。</p> <h3 id="std-basic-string"><a href="042-string-intro.html#std-basic-string" class="header-anchor">#</a> std::basic_string<CharT></CharT></h3> <p>いままで文字列の型として使ってきた<code>std::string</code>は、実はクラステンプレートで実装されている。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">namespace</span> std <span class="token punctuation">{</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span>
        <span class="token keyword">typename</span> charT<span class="token punctuation">,</span>
        <span class="token keyword">typename</span> traits <span class="token operator">=</span> char_traits<span class="token operator">&lt;</span>charT<span class="token operator">&gt;</span><span class="token punctuation">,</span>
        <span class="token keyword">typename</span> Allocator <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>charT<span class="token operator">&gt;</span>
    <span class="token operator">&gt;</span>
    <span class="token keyword">class</span> <span class="token class-name">basic_string</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>テンプレートパラメーターのうち、<code>charT</code>が文字型、<code>traits</code>は文字を処理するための補助的なライブラリ、<code>Allocator</code>がアロケーターだ。</p> <p>これに対し、以下のようなエイリアスが存在する。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">namespace</span> std <span class="token punctuation">{</span>
    <span class="token keyword">using</span> string    <span class="token operator">=</span> basic_string<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token punctuation">;</span>
    <span class="token keyword">using</span> u8string  <span class="token operator">=</span> basic_string<span class="token operator">&lt;</span>char8_t<span class="token operator">&gt;</span> <span class="token punctuation">;</span>
    <span class="token keyword">using</span> u16string <span class="token operator">=</span> basic_string<span class="token operator">&lt;</span><span class="token keyword">char16_t</span><span class="token operator">&gt;</span> <span class="token punctuation">;</span>
    <span class="token keyword">using</span> u32string <span class="token operator">=</span> basic_string<span class="token operator">&lt;</span><span class="token keyword">char32_t</span><span class="token operator">&gt;</span> <span class="token punctuation">;</span>  
    <span class="token keyword">using</span> wstring   <span class="token operator">=</span> basic_string<span class="token operator">&lt;</span><span class="token keyword">wchar_t</span><span class="token operator">&gt;</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>それぞれの文字型に対応した<code>basic_string</code>のクラスだ。</p> <p>これに対して、ユーザー定義リテラルという機能を使い、文字列リテラルのサフィックスに<code>s</code>を付けることで、文字列リテラルを対応する<code>basic_string</code>のクラス型に変換できる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// string</span>
<span class="token keyword">auto</span> str    <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span>s <span class="token punctuation">;</span>
<span class="token comment">// u8string</span>
<span class="token keyword">auto</span> u8str  <span class="token operator">=</span> u8<span class="token string">&quot;hello&quot;</span>s <span class="token punctuation">;</span>
<span class="token comment">// u16string</span>
<span class="token keyword">auto</span> u16str <span class="token operator">=</span> u<span class="token string">&quot;hello&quot;</span>s <span class="token punctuation">;</span>
<span class="token comment">// u32string</span>
<span class="token keyword">auto</span> u32str <span class="token operator">=</span> U<span class="token string">&quot;hello&quot;</span>s <span class="token punctuation">;</span>
<span class="token comment">// wstring</span>
<span class="token keyword">auto</span> wstr   <span class="token operator">=</span> L<span class="token string">&quot;hello&quot;</span>s <span class="token punctuation">;</span>
</code></pre></div><p>ユーザー定義リテラルの詳細については本書では詳しく説明しないが、演算子のオーバーロードと同じだ。演算子をオーバーロードするようにリテラル演算子をオーバーロードする。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>string <span class="token keyword">operator</span> <span class="token string">&quot;&quot;</span><span class="token function">s</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> ptr<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t n <span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span> ptr<span class="token punctuation">,</span> n <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token punctuation">}</span>
std<span class="token operator">::</span>u8string <span class="token keyword">operator</span> <span class="token string">&quot;&quot;</span><span class="token function">s</span><span class="token punctuation">(</span> <span class="token keyword">const</span> char8_t <span class="token operator">*</span> ptr<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t n <span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">u8string</span><span class="token punctuation">(</span> ptr<span class="token punctuation">,</span> n <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token punctuation">}</span>
std<span class="token operator">::</span>u16string <span class="token keyword">operator</span> <span class="token string">&quot;&quot;</span><span class="token function">s</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char16_t</span> <span class="token operator">*</span> ptr<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t n <span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">u16string</span><span class="token punctuation">(</span> ptr<span class="token punctuation">,</span> n <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token punctuation">}</span>
std<span class="token operator">::</span>u32string <span class="token keyword">operator</span> <span class="token string">&quot;&quot;</span><span class="token function">s</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char32_t</span> <span class="token operator">*</span> ptr<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t n <span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">u32string</span><span class="token punctuation">(</span> ptr<span class="token punctuation">,</span> n <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token punctuation">}</span>
std<span class="token operator">::</span>wstring <span class="token keyword">operator</span> <span class="token string">&quot;&quot;</span><span class="token function">s</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">wchar_t</span> <span class="token operator">*</span> ptr<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t n <span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">wstring</span><span class="token punctuation">(</span> ptr<span class="token punctuation">,</span> n <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre></div><p>ユーザー定義リテラルを正しく実装するには複雑なルールがある。例えばユーザー定義のサフィックス名はアンダースコア1つから始まっていなければならないなどだ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// OK</span>
<span class="token keyword">int</span> <span class="token keyword">operator</span> <span class="token string">&quot;&quot;</span> <span class="token function">_abc</span><span class="token punctuation">(</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token comment">// エラー、アンダースコア1つから始まっていない</span>
<span class="token keyword">int</span> <span class="token keyword">operator</span> <span class="token string">&quot;&quot;</span><span class="token function">abc</span><span class="token punctuation">(</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
</code></pre></div><p>これは将来の拡張のためにアンダースコアから始まらないサフィックス名をC++規格が予約しているためだ。</p> <p><code>basic_string</code>による文字列の表現方法は、文字型配列の先頭要素へのポインター、文字型配列のサイズ、アロケーターだ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span>
    <span class="token keyword">typename</span> charT<span class="token punctuation">,</span>
    <span class="token keyword">typename</span> traits <span class="token operator">=</span> char_traits<span class="token operator">&lt;</span>charT<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token keyword">typename</span> Allocator <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>charT<span class="token operator">&gt;</span>
<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">basic_string</span>
<span class="token punctuation">{</span>
    charT <span class="token operator">*</span> ptr <span class="token punctuation">;</span>
    std<span class="token operator">::</span>size_t size <span class="token punctuation">;</span>
    Allocator alloc <span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre></div><p>あるいは、配列のサイズを表現するために、配列の最後の要素の1つ次のポインターを使っているかもしれない。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>    charT <span class="token operator">*</span> ptr <span class="token punctuation">;</span>
    charT <span class="token operator">*</span> last <span class="token punctuation">;</span>
    Allocator alloc <span class="token punctuation">;</span>
</code></pre></div><p><code>std::vector</code>と同じで、どちらの方が効率がいいかはアーキテクチャにより異なる。</p> <p><code>basic_string</code>は文字列を表現するためのストレージを所有するクラスだ。コンストラクターでストレージを動的確保し、デストラクターで解放する。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 少なくともchar [5]を格納できるだけのストレージを動的確保する</span>
    std<span class="token operator">::</span>string <span class="token function">hello</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// helloが破棄される</span>
    <span class="token comment">// デストラクターはストレージを解放する</span>
<span class="token punctuation">}</span>
</code></pre></div><p>コピーはストレージの動的確保、ムーブはストレージの所有権の移動になる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>string s1 <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span> <span class="token punctuation">;</span>
    <span class="token comment">// コピー、動的確保</span>
    std<span class="token operator">::</span>string s2 <span class="token operator">=</span> s1 <span class="token punctuation">;</span>
    <span class="token comment">// ムーブ、所有権の移動</span>
    std<span class="token operator">::</span>string s3 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="std-basic-string-view"><a href="042-string-intro.html#std-basic-string-view" class="header-anchor">#</a> std::basic_string_view<CharT></CharT></h3> <p><code>basic_string_view</code>はストレージを所有しないクラスだ。以下のような宣言になる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">namespace</span> std <span class="token punctuation">{</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span>
        <span class="token keyword">typename</span> charT<span class="token punctuation">,</span>
        <span class="token keyword">typename</span> traits <span class="token operator">=</span> char_traits<span class="token operator">&lt;</span>charT<span class="token operator">&gt;</span>
    <span class="token operator">&gt;</span>
    <span class="token keyword">class</span> <span class="token class-name">basic_string_view</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>その実装は文字型へのポインター2つか、文字型へのポインター1つと配列のサイズを保持する整数型になる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>    charT <span class="token operator">*</span> first <span class="token punctuation">;</span>
    charT <span class="token operator">*</span> last <span class="token punctuation">;</span>
</code></pre></div><p>もしくは、</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>    charT <span class="token operator">*</span> first <span class="token punctuation">;</span>
    std<span class="token operator">::</span>size_t size <span class="token punctuation">;</span>
</code></pre></div><p><code>basic_string_view</code>には<code>basic_string</code>と対になる各文字型に対する特殊化がある。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">namespace</span> std <span class="token punctuation">{</span>
    <span class="token keyword">using</span> string_view    <span class="token operator">=</span> basic_string_view<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token punctuation">;</span>
    <span class="token keyword">using</span> u8string_view  <span class="token operator">=</span> basic_string_view<span class="token operator">&lt;</span>char8_t<span class="token operator">&gt;</span> <span class="token punctuation">;</span>
    <span class="token keyword">using</span> u16string_view <span class="token operator">=</span> basic_string_view<span class="token operator">&lt;</span><span class="token keyword">char16_t</span><span class="token operator">&gt;</span> <span class="token punctuation">;</span>
    <span class="token keyword">using</span> u32string_view <span class="token operator">=</span> basic_string_view<span class="token operator">&lt;</span><span class="token keyword">char32_t</span><span class="token operator">&gt;</span> <span class="token punctuation">;</span>  
    <span class="token keyword">using</span> wstring_view   <span class="token operator">=</span> basic_string_view<span class="token operator">&lt;</span><span class="token keyword">wchar_t</span><span class="token operator">&gt;</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>さらに、各<code>basic_string</code>に対するユーザー定義リテラルサフィックス<code>sv</code>がある。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// string_view</span>
<span class="token keyword">auto</span> str    <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span>sv <span class="token punctuation">;</span>
<span class="token comment">// u8string_view</span>
<span class="token keyword">auto</span> u8str  <span class="token operator">=</span> u8<span class="token string">&quot;hello&quot;</span>sv <span class="token punctuation">;</span>
<span class="token comment">// u16string_view</span>
<span class="token keyword">auto</span> u16str <span class="token operator">=</span> u<span class="token string">&quot;hello&quot;</span>sv <span class="token punctuation">;</span>
<span class="token comment">// u32string_view</span>
<span class="token keyword">auto</span> u32str <span class="token operator">=</span> U<span class="token string">&quot;hello&quot;</span>sv <span class="token punctuation">;</span>
<span class="token comment">// wstring_view</span>
<span class="token keyword">auto</span> wstr   <span class="token operator">=</span> L<span class="token string">&quot;hello&quot;</span>sv <span class="token punctuation">;</span>
</code></pre></div><p><code>basic_string_view</code>は文字列がnull終端文字列と<code>basic_string</code>のどちらで表現されていても問題なく受け取るためのクラスだ。この2つの文字列の表現を別々に使う場合、文字列を受け取る関数は、</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">process_string</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 文字列に対する処理</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">process_string</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span> s <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 文字列に対する上と同じ処理</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> null_terminated_string <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span> <span class="token punctuation">;</span>
    <span class="token keyword">auto</span> basic_string <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span>s <span class="token punctuation">;</span>

    <span class="token comment">// const char *</span>
    <span class="token function">process_string</span><span class="token punctuation">(</span> null_terminated_string <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// const std::string &amp;</span>
    <span class="token function">process_string</span><span class="token punctuation">(</span> basic_string <span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>のようにほとんど同じ関数を2つ書かなければならない。<code>basic_string_view</code>を使えば、</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">process_string</span><span class="token punctuation">(</span> std<span class="token operator">::</span>string_view s <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 文字列に対する処理</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> null_terminated_string <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span> <span class="token punctuation">;</span>
    <span class="token keyword">auto</span> basic_string <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span>s <span class="token punctuation">;</span>

    <span class="token comment">// どちらも同じ関数を呼ぶ</span>
    <span class="token function">process_string</span><span class="token punctuation">(</span> null_terminated_string <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token function">process_string</span><span class="token punctuation">(</span> basic_string <span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>のように、どちらの文字列表現を使っても1つの関数を書くだけで済む。</p> <p><code>basic_string_view</code>はストレージを所有しないので関数の引数として使うときはリファレンスで取る必要はない。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// リファレンスで取る必要はない</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string_view <span class="token operator">&amp;</span> ref <span class="token punctuation">)</span> 
<span class="token comment">// これでいい</span>
<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span> std<span class="token operator">::</span>string_view obj <span class="token punctuation">)</span> <span class="token punctuation">;</span>
</code></pre></div><h2 id="文字列の操作"><a href="042-string-intro.html#文字列の操作" class="header-anchor">#</a> 文字列の操作</h2> <h3 id="null終端文字列の操作"><a href="042-string-intro.html#null終端文字列の操作" class="header-anchor">#</a> null終端文字列の操作</h3> <p>null終端文字列は文字列の先頭となる文字型へのポインター型のオブジェクト1つで表現されるので、文字型の配列のサイズを取得するにも、いちいちnull文字が見つかるまでポインターをインクリメントしていく必要がある。この処理をやってくれるのが<code>std::strlen</code>だ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> ptr <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> size <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">strlen</span><span class="token punctuation">(</span> ptr <span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>文字列リテラルの型は<code>const</code>な文字型の配列なので、文字列を変更することができない。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span> <span class="token punctuation">;</span>
<span class="token comment">// エラー</span>
ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'x'</span> <span class="token punctuation">;</span>
</code></pre></div><p>文字型への配列ならば変更できる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span> <span class="token punctuation">;</span>
    s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'x'</span> <span class="token punctuation">;</span>
    <span class="token comment">// sは{'x','b','c','\0'}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>文字の長さを短くしたい場合は、終端をnull文字にする。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span> <span class="token punctuation">;</span>
    s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span> <span class="token punctuation">;</span>
    <span class="token comment">// sは{'a','\0', 'c','\0'}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>この変数<code>s</code>の型は<code>char [4]</code>だが、null終端文字列としてのサイズは1だ。</p> <p>文字列のサイズを長くするには、当然大きな配列が必要になる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span> <span class="token punctuation">;</span>
    s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'d'</span> <span class="token punctuation">;</span>
    s<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'e'</span> <span class="token punctuation">;</span>
    s<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'f'</span> <span class="token punctuation">;</span>
    s<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>このコードで、変数<code>s</code>は最終的に<code>&quot;abcdef&quot;</code>という文字列になる。最後のnull文字による終端を忘れてはならない。</p> <p>ここで、配列<code>s</code>の要素数は7以上でなければならない。最終的なnull終端文字列を表現するには最低でも<code>char [7]</code>が必要だからだ。</p> <p>例えば2つのnull終端文字列を結合する場合で、どちらも<code>const</code>であったり、十分なサイズがなかった場合、2つの文字列を保持できるサイズのメモリーを確保して、コピーしなければならない。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// s1, s2を結合して使う関数</span>
<span class="token keyword">void</span> <span class="token function">concat_str</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>  s1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s2 <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 2つの文字列のサイズの合計 + null文字</span>
    <span class="token keyword">auto</span> size <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">strlen</span><span class="token punctuation">(</span> s1 <span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span><span class="token function">strlen</span><span class="token punctuation">(</span> s2 <span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">;</span>
    <span class="token comment">// 文字列を保持するメモリーを確保する</span>
    <span class="token keyword">char</span> <span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token punctuation">;</span>

    <span class="token keyword">char</span> <span class="token operator">*</span> i <span class="token operator">=</span> ptr <span class="token punctuation">;</span>
    <span class="token comment">// s1をコピー</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">*</span>s1 <span class="token operator">!=</span> <span class="token string">'\0'</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token operator">*</span>i <span class="token operator">=</span> <span class="token operator">*</span>s1 <span class="token punctuation">;</span>
        <span class="token operator">++</span>i <span class="token punctuation">;</span> <span class="token operator">++</span>s1 <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// s2をコピー</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">*</span>s2 <span class="token operator">!=</span> <span class="token string">'\0'</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token operator">*</span>i <span class="token operator">=</span> <span class="token operator">*</span>s2 <span class="token punctuation">;</span>
        <span class="token operator">++</span>i <span class="token punctuation">;</span> <span class="token operator">++</span>s2 <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// null終端する</span>
    <span class="token operator">*</span>i <span class="token operator">=</span> <span class="token string">'\0'</span> <span class="token punctuation">;</span>

    <span class="token comment">// 結合した文字列を使う</span>

    <span class="token comment">// 使い終わったのでメモリーを解放する</span>
    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ptr <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>C言語の標準ライブラリにはnull終端文字列を扱うためのライブラリが多数ある。C言語の標準ライブラリを使えば、上のコードは以下のように書ける。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">concat_str</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>  s1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s2 <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> size <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">strlen</span><span class="token punctuation">(</span> s1 <span class="token punctuation">)</span> <span class="token operator">+</span> std<span class="token operator">::</span><span class="token function">strlen</span><span class="token punctuation">(</span> s2 <span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token punctuation">;</span>

    <span class="token comment">// s1をptrにコピー</span>
    std<span class="token operator">::</span><span class="token function">strcpy</span><span class="token punctuation">(</span> ptr<span class="token punctuation">,</span> s1 <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// ptrとs2を結合</span>
    std<span class="token operator">::</span><span class="token function">strcat</span><span class="token punctuation">(</span> ptr<span class="token punctuation">,</span> s2 <span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ptr <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="basic-stringの操作"><a href="042-string-intro.html#basic-stringの操作" class="header-anchor">#</a> basic_stringの操作</h3> <p><code>basic_string</code>はストレージを所有するクラスだ。ストレージの解放と確保を自動でやってくれる上に、便利な操作がたくさんある。</p> <p>例えば上の<code>concat_str</code>を<code>basic_string</code>で実装すると以下のようになる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">concat_str</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>  s1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s2 <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>string s <span class="token operator">=</span> s1 <span class="token punctuation">;</span>
    s <span class="token operator">+=</span> s2 <span class="token punctuation">;</span>

    <span class="token comment">// sを使う</span>
    <span class="token comment">// sは自動的に破棄される</span>
<span class="token punctuation">}</span>
</code></pre></div><p>C++の作法に従って、引数<code>s1, s2</code>をnull終端文字列文字型ではなく、<code>basic_string_view</code>にすると以下のようになる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">concat_str</span><span class="token punctuation">(</span> std<span class="token operator">::</span>string_view s1<span class="token punctuation">,</span> std<span class="token operator">::</span>string_view s2 <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>string s <span class="token operator">=</span> s1 <span class="token punctuation">;</span>
    s <span class="token operator">+=</span> s2 <span class="token punctuation">;</span>

    <span class="token comment">// sを使う</span>
    <span class="token comment">// sは自動的に破棄される</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="初期化"><a href="042-string-intro.html#初期化" class="header-anchor">#</a> 初期化</h4> <p><code>basic_string</code>はnull終端文字列、<code>basic_string_view</code>、<code>basic_string</code>で初期化、代入できる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// null終端文字列</span>
std<span class="token operator">::</span>string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token comment">// basic_string_view</span>
std<span class="token operator">::</span>string <span class="token function">s2</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token comment">// basic_string</span>
std<span class="token operator">::</span>string <span class="token function">s3</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span>s<span class="token punctuation">)</span> <span class="token punctuation">;</span>
</code></pre></div><h4 id="結合"><a href="042-string-intro.html#結合" class="header-anchor">#</a> 結合</h4> <p><code>basic_string</code>は<code>operator +</code>で文字列を結合できる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// &quot;foobar&quot;</span>
<span class="token keyword">auto</span> s <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span>s <span class="token operator">+</span> <span class="token string">&quot;bar&quot;</span>s <span class="token punctuation">;</span>
</code></pre></div><p><code>operator +=</code>は第一オペランドを書き換える。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> s <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span>s <span class="token punctuation">;</span>
s <span class="token operator">+=</span> <span class="token string">&quot;bar&quot;</span>s <span class="token punctuation">;</span>
<span class="token comment">// sは&quot;foobar&quot;</span>
</code></pre></div><p><code>basic_string::append(s)</code>というメンバー関数もある。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> s <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span>s <span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;bar&quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token comment">// sは&quot;foobar&quot; </span>
</code></pre></div><h4 id="イテレーター"><a href="042-string-intro.html#イテレーター" class="header-anchor">#</a> イテレーター</h4> <p><code>basic_string</code>にはイテレーターがある。イテレーターの取得方法は<code>std::vector</code>と同じだ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> s <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span>s <span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">auto</span> i <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> i <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token operator">++</span>i <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>i <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>これは以下のようにも書ける。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">auto</span> i <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">;</span> i <span class="token operator">!=</span> std<span class="token operator">::</span><span class="token function">end</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token operator">++</span>i <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>i <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="部分文字列の検索"><a href="042-string-intro.html#部分文字列の検索" class="header-anchor">#</a> 部分文字列の検索</h4> <p>イテレーターがあるので、<code>basic_string</code>は汎用的なアルゴリズムに渡すことができる。例えばある文字列がその一部の別の文字列を含むかどうかを調べる場合、以下のように書ける。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> text <span class="token operator">=</span> <span class="token string">&quot;quick brown fox jumps over the lazy dog.&quot;</span>s <span class="token punctuation">;</span>
    <span class="token keyword">auto</span> word <span class="token operator">=</span> <span class="token string">&quot;fox&quot;</span>s <span class="token punctuation">;</span>

    <span class="token keyword">auto</span> i <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">search</span><span class="token punctuation">(</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">end</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">end</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span> i <span class="token operator">!=</span> std<span class="token operator">::</span><span class="token function">end</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token punctuation">)</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;fox found!\n&quot;</span>sv <span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;no fox...\n&quot;</span>sv <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>イテレーターを使うのは煩わしいが、C++20では<code>Range</code>ライブラリが追加され、以下のように書ける予定だ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> r <span class="token operator">=</span> std<span class="token operator">::</span>ranges<span class="token operator">::</span><span class="token function">search</span><span class="token punctuation">(</span> text<span class="token punctuation">,</span> word <span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>std<span class="token operator">::</span>ranges<span class="token operator">::</span><span class="token function">empty</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token punctuation">)</span>
    <span class="token comment">// ...</span>
</code></pre></div><p>名前空間を省くと、<code>!empty( search( text, word) )</code> になるが、これでもまだわかりづらい。そこで<code>basic_string::find</code>がある。これは<code>&lt;algorithm&gt;</code>の<code>std::find</code>とは別物で、文字列から部分文字列を探し、その部分文字列に一致する文字へのインデックスを返す。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> text <span class="token operator">=</span> <span class="token string">&quot;quick brown fox jumps over the lazy dog.&quot;</span>s <span class="token punctuation">;</span>

    <span class="token comment">// 12</span>
    <span class="token keyword">auto</span> fox <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;fox&quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// 32</span>
    <span class="token keyword">auto</span> dog <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;dog&quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>文字列<code>&quot;fox&quot;</code>に一致する部分文字列の先頭<code>'f'</code>の文字型の値へのインデックスは<code>12</code>で、<code>&quot;dog&quot;</code>の<code>'d'</code>は<code>36</code>だ。この結果は、上のソースコードに使っている文字が1文字につき1文字型の値を使うためだ。通常は文字数と連続した文字型の要素へのインデックスは等しくならない。</p> <p>例えば以下のコードを実行すると、</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> text <span class="token operator">=</span> u8<span class="token string">&quot;すばしっこい茶色の狐がノロマな犬を飛び越した。&quot;</span>s <span class="token punctuation">;</span>

    <span class="token keyword">auto</span> fox <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>u8<span class="token string">&quot;狐&quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token keyword">auto</span> dog <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>u8<span class="token string">&quot;犬&quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>

    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;fox: &quot;</span>sv <span class="token operator">&lt;&lt;</span> fox <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\n&quot;</span>sv
            <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;dog: &quot;</span>sv <span class="token operator">&lt;&lt;</span> dog <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以下のように出力される。</p> <div class="language- extra-class"><pre class="language-text"><code>fox: 27
dog: 45
</code></pre></div><p>もし部分文字列が見つからない場合、<code>basic_string::npos</code>が返る。<code>npos</code>は&quot;no position&quot;という意味で、<code>-1</code>と等しい。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> text <span class="token operator">=</span> <span class="token string">&quot;quick brown fox jumps over the lazy dog.&quot;</span>s <span class="token punctuation">;</span>

    <span class="token comment">// 見つからない場合はnposが返る。   </span>
    <span class="token keyword">auto</span> index <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token comment">// 見つからなかった判定</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> index <span class="token operator">!=</span> std<span class="token operator">::</span>string<span class="token operator">::</span>npos <span class="token punctuation">)</span>
        <span class="token comment">// 見つかった</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;found.&quot;</span> <span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token comment">// 見つからなかった</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;not found.&quot;</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>この場合、変数<code>text</code>に文字列<code>&quot;abc&quot;</code>はないので、<code>npos</code>が返る。<code>npos</code>が返ったかどうかは<code>npos</code>と比較すればわかる。<code>npos</code>は<code>-1</code>と等しいので、以下のようにも書ける。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span> index <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span>
    <span class="token comment">// ...</span>
</code></pre></div><p><code>find</code>の亜種として、<code>rfind</code>がある。</p> <p><code>find</code>は最初の部分文字列を見つけるが、<code>rfind</code>は最後の部分文字列を見つける。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> text <span class="token operator">=</span> <span class="token string">&quot;word word word&quot;</span>s <span class="token punctuation">;</span>

    <span class="token comment">// 0</span>
    <span class="token keyword">auto</span> first <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;word&quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// 10</span>
    <span class="token keyword">auto</span> last <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">rfind</span><span class="token punctuation">(</span><span class="token string">&quot;word&quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>find</code>は最初に一致した部分文字列の先頭へのインデックスを返すので、この場合<code>0</code>が返る。<code>rfind</code>は最後に見つかった部分文字列の先頭へのインデックスを返すので、この場合<code>10</code>になる。</p> <p>C++20では、<code>starts_with/ends_with</code>という2つの便利なメンバー関数が追加される。</p> <p><code>starts_with(str)</code>は文字列が部分文字列<code>str</code>で始まっている場合に<code>true</code>を返す。そうでない場合は<code>false</code>を返す。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> text <span class="token operator">=</span> <span class="token string">&quot;aa bb cc&quot;</span>s <span class="token punctuation">;</span>

    <span class="token comment">// true</span>
    <span class="token keyword">bool</span> b1 <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">starts_with</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token keyword">bool</span> b2 <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">starts_with</span><span class="token punctuation">(</span><span class="token string">&quot;aa&quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token keyword">bool</span> b3 <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">starts_with</span><span class="token punctuation">(</span><span class="token string">&quot;aa &quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token comment">// false</span>
    <span class="token keyword">bool</span> b4 <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">starts_with</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token keyword">bool</span> b5 <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">starts_with</span><span class="token punctuation">(</span><span class="token string">&quot;aaa&quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>ends_with(str)</code>は文字列が部分文字列<code>str</code>で終わっている場合に<code>true</code>を返す。そうでない場合は<code>false</code>を返す。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> text <span class="token operator">=</span> <span class="token string">&quot;aa bb cc&quot;</span>s <span class="token punctuation">;</span>

    <span class="token comment">// true</span>
    <span class="token keyword">bool</span> b1 <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">ends_with</span><span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token keyword">bool</span> b2 <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">ends_with</span><span class="token punctuation">(</span><span class="token string">&quot;cc&quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token keyword">bool</span> b3 <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">ends_with</span><span class="token punctuation">(</span><span class="token string">&quot; cc &quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token comment">// false</span>
    <span class="token keyword">bool</span> b4 <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">ends_with</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token keyword">bool</span> b5 <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">ends_with</span><span class="token punctuation">(</span><span class="token string">&quot;ccc&quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="その他のメンバー関数"><a href="042-string-intro.html#その他のメンバー関数" class="header-anchor">#</a> その他のメンバー関数</h4> <p><code>size</code>, <code>empty</code>, <code>resize</code>, <code>capacity</code>, <code>reserve</code>, <code>shrink_to_fit</code>, <code>clear</code>といったおなじみのメンバー関数もある。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>string s <span class="token punctuation">;</span>
    s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    s<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
    s<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="文字列の挿入"><a href="042-string-intro.html#文字列の挿入" class="header-anchor">#</a> 文字列の挿入</h4> <p>文字列の挿入は<code>insert( pos, str )</code> で行える。</p> <p><code>pos</code>は挿入場所へのインデックスで、<code>str</code>は挿入する文字列だ。</p> <p>文字列の先頭や末尾への挿入は以下のようになる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> text <span class="token operator">=</span> <span class="token string">&quot;cat&quot;</span>s <span class="token punctuation">;</span>
    text<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;long &quot;</span>sv <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// textは&quot;long cat&quot;</span>
    text<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> text<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot; is loong.&quot;</span>sv <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// textは&quot;long cat is loong.&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>末尾への挿入は文字列の結合と同じ効果だ。</p> <p>インデックスで中間に挿入するのは以下のとおり。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> text <span class="token operator">=</span> <span class="token string">&quot;big cat&quot;</span>s <span class="token punctuation">;</span>
    text<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span> text<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;cat&quot;</span>sv<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;fat &quot;</span>sv <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// textは&quot;big fat cat&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>これは<code>text.find(&quot;cat&quot;sv)</code>でまず部分文字列<code>&quot;cat&quot;</code>の先頭へのインデックスを探し、そこに文字列<code>&quot;fat &quot;</code>を挿入している。結果として変数<code>text</code>は<code>&quot;big fat cat&quot;</code>となる。</p> <h4 id="部分文字列の削除"><a href="042-string-intro.html#部分文字列の削除" class="header-anchor">#</a> 部分文字列の削除</h4> <p>文字列から部分文字列を削除するには<code>erase( pos, n )</code>を使う。<code>pos</code>は削除すべき先頭のインデックスで、<code>n</code>は削除すべきインデックス数だ。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> text <span class="token operator">=</span> <span class="token string">&quot;dirty cat&quot;</span>s <span class="token punctuation">;</span>
    <span class="token keyword">auto</span> dirty <span class="token operator">=</span> <span class="token string">&quot;dirty &quot;</span>sv <span class="token punctuation">;</span>
    text<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> dirty<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// textは&quot;cat&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>このプログラムは文字列<code>&quot;dirty cat&quot;</code>から<code>&quot;dirty &quot;</code>を削除し、<code>&quot;cat&quot;</code>にする。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> text <span class="token operator">=</span> <span class="token string">&quot;big fat cat&quot;</span>s <span class="token punctuation">;</span>
    <span class="token keyword">auto</span> fat <span class="token operator">=</span> <span class="token string">&quot;fat &quot;</span>sv <span class="token punctuation">;</span>
    text<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span> text<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>fat<span class="token punctuation">)</span><span class="token punctuation">,</span> fat<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// textは&quot;big cat&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>このプログラムは文字列<code>&quot;big fat cat&quot;</code>から部分文字列<code>&quot;fat&quot;</code>を検索し、その先頭から変数<code>fat</code>のサイズ文の部分文字列を削除する。結果として変数<code>text</code>は<code>&quot;big cat&quot;</code>になる。</p> <p>先頭から末尾までを削除すると、<code>clear()</code>と同じ意味になる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> text <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span>s <span class="token punctuation">;</span>
    text<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> text<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// text.empty() == true</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="部分文字列の置換"><a href="042-string-intro.html#部分文字列の置換" class="header-anchor">#</a> 部分文字列の置換</h4> <p><code>replace( pos, n1, str )</code>を使うと、文字列のインデックス<code>pos</code>から<code>n1</code>個までの文字型の値を、文字列<code>str</code>で置き換える。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> text <span class="token operator">=</span> <span class="token string">&quot;ugly cat&quot;</span>s <span class="token punctuation">;</span>
    <span class="token keyword">auto</span> ugly <span class="token operator">=</span> <span class="token string">&quot;ugly&quot;</span>sv <span class="token punctuation">;</span>
    <span class="token keyword">auto</span> pretty <span class="token operator">=</span> <span class="token string">&quot;pretty&quot;</span>sv <span class="token punctuation">;</span>
    text<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span> text<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>ugly<span class="token punctuation">)</span><span class="token punctuation">,</span> ugly<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pretty <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// textは&quot;pretty cat&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>このコードは、文字列<code>text</code>から部分文字列<code>&quot;ugly&quot;</code>を探し、その先頭へのインデックスと文字列<code>&quot;ugly&quot;</code>のサイズを指定することで、部分文字列<code>&quot;ugly&quot;</code>を、文字列<code>pretty</code>の値である<code>&quot;pretty&quot;</code>に置換する。結果として<code>text</code>は<code>&quot;pretty cat&quot;</code>になる。</p> <h4 id="その他の推奨できない操作"><a href="042-string-intro.html#その他の推奨できない操作" class="header-anchor">#</a> その他の推奨できない操作</h4> <p><code>basic_string</code>にはこのほかにさまざまな、現代では推奨できない操作がある。</p> <p>例えば<code>operator []</code>で文字列をインデックスでアクセスできる。これは基本実行文字セットに対しては動く。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> text <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span>s <span class="token punctuation">;</span>
    <span class="token comment">// 'a'</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> text<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>
    <span class="token comment">// 'b'</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> text<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>

    text<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'x'</span> <span class="token punctuation">;</span>
    <span class="token comment">// textは&quot;xbc&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>これは、<code>basic_string</code>が設計された時代は、1文字型は1文字を表現できるという前提があったからだ。</p> <p>現代の文字列の表現方法であるUnicodeとUTFによるエンコードではこの前提が成り立たない。例えば、最もよく使われているUTF-8の場合、以下のようになる。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> text <span class="token operator">=</span> u8<span class="token string">&quot;いろは&quot;</span>s <span class="token punctuation">;</span>
    <span class="token comment">// 0xe3</span>
    <span class="token keyword">auto</span> c <span class="token operator">=</span> text<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>text</code>のインデックス<code>0</code>にあたる文字型の値は<code>u8'い'</code>ではない。UTF-8は文字「い」を文字型1つで表現できないからだ。<code>u8&quot;いろは&quot;</code>というUTF-8文字列リテラルはすでに学んだように、以下のように表現される。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// u8&quot;いろは&quot;</span>
char8_t iroha<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0xe3</span><span class="token punctuation">,</span> <span class="token number">0x81</span><span class="token punctuation">,</span> <span class="token number">0x84</span><span class="token punctuation">,</span> <span class="token number">0xe3</span><span class="token punctuation">,</span> <span class="token number">0x82</span><span class="token punctuation">,</span> <span class="token number">0x8d</span><span class="token punctuation">,</span> <span class="token number">0xe3</span><span class="token punctuation">,</span> <span class="token number">0x81</span><span class="token punctuation">,</span> <span class="token number">0xaf</span><span class="token punctuation">,</span> <span class="token number">0x0</span> <span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre></div><p>文字「い」をUTF-8で表現するためには、<code>char8_t</code>型の値が3つ必要で、<code>0xe3, 0x81, 0x84</code>というシーケンスでなければならない。そのため、個々の文字型の値をインデックスでアクセスしても意味がない。また、<code>size()</code>は文字数を返すのではなく、インデックス数を返す。</p> <p><code>basic_string</code>にはリバースイテレーターを返す<code>rbegin/rend</code>もあるが、Unicodeでエンコードされた文字列では、複数の値のシーケンスで1文字を表現しているため、単に値単位で逆順のイテレートすることは、技術的には可能だが、意味的には壊れてしまう。</p> <p><code>basic_string</code>には最初に発見したいずれかの文字へのインデックスを返す<code>find_first_of</code>がある。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> text <span class="token operator">=</span> <span class="token string">&quot;quick brown fox jumps over the lazy dog.&quot;</span>s <span class="token punctuation">;</span>
    <span class="token comment">// 3</span>
    <span class="token keyword">auto</span> i <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span>sv<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>i</code>は<code>3</code>になる。なぜならば、<code>find_first_of(&quot;abc&quot;sv)</code>は<code>a</code>, <code>b</code>, <code>c</code>のうちいずれかの文字である最初のインデックスを返すからだ。</p> <p>この機能はUnicodeでは使えない。というのも1文字型で1文字を表現できないからだ。</p> <h3 id="basic-string-viewの操作"><a href="042-string-intro.html#basic-string-viewの操作" class="header-anchor">#</a> basic_string_viewの操作</h3> <p><code>basic_string_view</code>は<code>basic_string</code>とほぼ同じ操作が行える。ただし、<code>basic_string_view</code>は書き換えることができないので、一部の操作が使えない。<code>append, insert, erase, replace</code>は使えない。<code>basic_string_view</code>同士の<code>operator +</code>もない。</p> <p>C++20では、文字列の先頭と末尾を指定したインデックス数分削ることはできる。</p> <p>先頭を削るには<code>remove_prefix(i)</code>を使う。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> text <span class="token operator">=</span> <span class="token string">&quot;quick brown fox jumps over the lazy dog.&quot;</span> <span class="token punctuation">;</span>
    text<span class="token punctuation">.</span><span class="token function">remove_prefix</span><span class="token punctuation">(</span> <span class="token string">&quot;quick &quot;</span>sv<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// textは&quot;brown fox jumps over the lazy dog.&quot;</span>
    text<span class="token punctuation">.</span><span class="token function">remove_prefix</span><span class="token punctuation">(</span> <span class="token string">&quot;brown&quot;</span>sv<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// textは&quot;fox jumps over the lazy dog.&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>末尾を削るには<code>remove_suffix(i)</code>を使う。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> text <span class="token operator">=</span> <span class="token string">&quot;quick brown fox jumps over the lazy dog.&quot;</span> <span class="token punctuation">;</span>
    text<span class="token punctuation">.</span><span class="token function">remove_suffix</span><span class="token punctuation">(</span> <span class="token string">&quot; dog.&quot;</span>sv<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// textは&quot;quick brown fox jumps over the lazy&quot;</span>
    text<span class="token punctuation">.</span><span class="token function">remove_suffix</span><span class="token punctuation">(</span> <span class="token string">&quot; lazy&quot;</span><span class="token punctuation">.</span>sv<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token comment">// textは&quot;quick brown fox jumps over the&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="041-move-support.html" class="prev">自作の数値クラスで演算をムーブに対応する方法</a></span> <span class="next"><a href="043-random.html">乱数</a>
      →
    </span></p></div> </main></div><div class="global-ui"><SWUpdatePopup></SWUpdatePopup></div></div>
    <script src="assets/js/app.8620998f.js" defer></script><script src="assets/js/2.7009e9ba.js" defer></script><script src="assets/js/47.483b5213.js" defer></script>
  </body>
</html>
